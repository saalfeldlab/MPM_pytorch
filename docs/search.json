[
  {
    "objectID": "variable-schematic.html",
    "href": "variable-schematic.html",
    "title": "Variable Schematic",
    "section": "",
    "text": "This diagram shows how variables in MPM_step.py correspond to the mathematical quantities in MPM.\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         MPM TIME STEP VARIABLE FLOW                         │\n└─────────────────────────────────────────────────────────────────────────────┘\n\nINPUT STATE (per particle)\n┌──────────┬─────────────┬──────────────────────────────────────────────────┐\n│ Variable │ Math Symbol │ Description                                      │\n├──────────┼─────────────┼──────────────────────────────────────────────────┤\n│ X        │ xᵢ          │ Position [n_particles, 2]                        │\n│ V        │ vᵢ          │ Velocity [n_particles, 2]                        │\n│ C        │ Cᵢ          │ Affine velocity matrix [n_particles, 2, 2]       │\n│ F        │ Fᵢ          │ Deformation gradient [n_particles, 2, 2]         │\n│ Jp       │ Jₚ          │ Plastic volume ratio [n_particles, 1]            │\n│ T        │ type        │ Material type (0=liquid, 1=jelly, 2=snow)        │\n│ M        │ mᵢ          │ Mass [n_particles, 1]                            │\n└──────────┴─────────────┴──────────────────────────────────────────────────┘\n\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 1: DEFORMATION GRADIENT UPDATE                                      ║\n║                                                                           ║\n║    F = (I + dt*C) @ F                                                     ║\n║                                                                           ║\n║  Code: F = (identity + dt * C) @ F                            Line 49    ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 1-&gt;2: MATERIAL-SPECIFIC F REFINEMENT                                │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │  SVD DECOMPOSITION                                                  │  │\n│  │                                                                     │  │\n│  │    F = U * Sigma * V^T                                              │  │\n│  │                                                                     │  │\n│  │  Code: U, sig, Vh = torch.linalg.svd(F_reg)            Line 64     │  │\n│  │                                                                     │  │\n│  │  Variables:                                                         │  │\n│  │    U, Vh  -&gt; rotation matrices [n_particles, 2, 2]                  │  │\n│  │    sig    -&gt; singular values (stretches) [n_particles, 2]           │  │\n│  │    J      -&gt; det(F) = sig1*sig2 = torch.prod(sig)                   │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                    │                                      │\n│      ┌─────────────────────────────┼─────────────────────────────┐        │\n│      ▼                             ▼                             ▼        │\n│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐  │\n│  │    LIQUID     │          │     JELLY     │          │     SNOW      │  │\n│  │   (T == 0)    │          │   (T == 1)    │          │   (T == 2)    │  │\n│  ├───────────────┤          ├───────────────┤          ├───────────────┤  │\n│  │ mu = 0        │          │ h = 0.3       │          │ h = exp(10*   │  │\n│  │ (no shear)    │          │ (constant)    │          │    (1-Jp))    │  │\n│  │               │          │               │          │               │  │\n│  │ F = sqrt(J)*I │          │ sig clamped   │          │ sig clamped   │  │\n│  │ (isotropic)   │          │ F = U*Sig*V^T │          │ [0.975,1.0045]│  │\n│  │               │          │               │          │ Jp updated    │  │\n│  └───────────────┘          └───────────────┘          └───────────────┘  │\n│      │                             │                             │        │\n│      └─────────────────────────────┼─────────────────────────────┘        │\n│                                    ▼                                      │\n│  Code references:                                                         │\n│    - Hardening: h = torch.exp(10 * (1.0 - Jp.squeeze()))      Line 51    │\n│    - Jelly h:   h = torch.where(jelly_mask, 0.3, h)           Line 52    │\n│    - Lame:      mu = mu_0 * h, la = lambda_0 * h              Lines 55-56│\n│    - Liquid mu: mu = torch.where(liquid_mask, 0.0, mu)        Line 57    │\n│    - Snow clamp: sig = torch.clamp(sig, 1-2.5e-2, 1+4.5e-3)   Line 98    │\n│    - Jp update: Jp = Jp * plastic_ratio                       Line 102   │\n│    - Liquid F:  F_liquid = identity * sqrt(J)                 Line 112   │\n│    - Solid F:   F_solid = U @ sig_diag @ Vh                   Line 113   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 2: STRESS COMPUTATION                                               ║\n║                                                                           ║\n║    R = U * V^T                   (rotation component)                     ║\n║                                                                           ║\n║    stress = 2*mu*(F-R)*F^T + la*J*(J-1)*I   (Cauchy, corotated model)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    R = U @ Vh                                                 Line 123   ║\n║    F_minus_R = F - R                                          Line 124   ║\n║    stress = (2*mu*(F-R)@F^T + la*J*(J-1)*I)                  Line 125-126║\n║    stress = (-dt * p_vol * 4 * inv_dx^2) * stress            Line 127    ║\n║                                                                           ║\n║  The scaling factor converts stress to force for P2G transfer             ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 2-&gt;3: AFFINE MOMENTUM COMPUTATION                                   │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │                                                                     │  │\n│  │     affine = stress + m * C                                         │  │\n│  │                                                                     │  │\n│  │  Code: affine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C    │  │\n│  │                                                        Line 162    │  │\n│  │                                                                     │  │\n│  │  Physical interpretation:                                           │  │\n│  │    - stress term: internal forces from deformation                  │  │\n│  │    - m*C term: momentum transport (APIC angular momentum)           │  │\n│  │                                                                     │  │\n│  │  This combined \"affine\" carries BOTH force AND momentum info        │  │\n│  │  to the grid in a single transfer.                                  │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                                                           │\n│  Variables at this point:                                                 │\n│  ┌────────────┬─────────────┬────────────────────────────────────────┐   │\n│  │ Variable   │ Shape       │ Description                            │   │\n│  ├────────────┼─────────────┼────────────────────────────────────────┤   │\n│  │ stress     │ [N, 2, 2]   │ Scaled stress (force)                  │   │\n│  │ C          │ [N, 2, 2]   │ Affine velocity matrix                 │   │\n│  │ p_mass     │ [N]         │ Particle mass                          │   │\n│  │ affine     │ [N, 2, 2]   │ Combined force + momentum gradient     │   │\n│  └────────────┴─────────────┴────────────────────────────────────────┘   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 3: P2G TRANSFER (Particle to Grid)                                  ║\n║                                                                           ║\n║  Each particle i CONTRIBUTES to its 9 neighboring grid nodes j:           ║\n║                                                                           ║\n║    contribution to mass:     dm_j = w_j * m_i                             ║\n║    contribution to momentum: dp_j = w_j * (m_i*v_i + Q_i*(x_j - x_i))     ║\n║                                                                           ║\n║  The GNN ACCUMULATES all particle contributions at each grid node:        ║\n║                                                                           ║\n║    m_j = SUM_i dm_j   (total mass at node j)                              ║\n║    p_j = SUM_i dp_j   (total momentum at node j)                          ║\n║                                                                           ║\n║  Code (MPM_P2G.message computes d, GNN aggregation computes SUM):         ║\n║    out_m = mass_j * weights              # dm_j contribution              ║\n║    out_v = weights * (m*v + Q @ dpos)    # dp_j contribution              ║\n║                                                                           ║\n║  After GNN aggregation (Line 214-216):                                    ║\n║    grid_m = accumulated mass m_j     [n_grid, n_grid]                     ║\n║    grid_v = accumulated momentum p_j [n_grid, n_grid, 2] (NOT velocity!)  ║\n║                                                                           ║\n║  Weights: Quadratic B-spline w0, w1, w2                     Lines 178-181 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 4: GRID OPERATIONS                                                  ║\n║                                                                           ║\n║    v_j = p_j / m_j               (momentum -&gt; velocity, using accumulated)║\n║    v_j += dt * g                 (gravity)                                ║\n║    Apply boundary conditions     (friction, no-penetration)               ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    grid_v = grid_v / (grid_m + eps)                         Line 226-228  ║\n║    grid_v = grid_v + gravity_force                          Line 232-234  ║\n║    Boundary handling                                        Lines 242-266 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 5: G2P TRANSFER                                                     ║\n║                                                                           ║\n║    v_i = SUM_j w_j * v_j              (APIC velocity update)              ║\n║                                                                           ║\n║    C_i = 4/dx^2 * SUM_j w_j * v_j (x) (x_j - x_i)   (affine velocity)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    new_V = SUM weights * g_v_all                            Line 304-305  ║\n║    outer_products = g_v @ dpos^T                            Line 309-311  ║\n║    new_C = 4 * inv_dx * SUM weights * outer_products        Line 315      ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 6: ADVECTION                                                        ║\n║                                                                           ║\n║    x_i = x_i + dt * v_i                                                   ║\n║                                                                           ║\n║  Code: X = X + dt * new_V                                       Line 322  ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\nOUTPUT STATE: X, V, C, F, Jp (updated)"
  },
  {
    "objectID": "variable-schematic.html#complete-variable-flow",
    "href": "variable-schematic.html#complete-variable-flow",
    "title": "Variable Schematic",
    "section": "",
    "text": "This diagram shows how variables in MPM_step.py correspond to the mathematical quantities in MPM.\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         MPM TIME STEP VARIABLE FLOW                         │\n└─────────────────────────────────────────────────────────────────────────────┘\n\nINPUT STATE (per particle)\n┌──────────┬─────────────┬──────────────────────────────────────────────────┐\n│ Variable │ Math Symbol │ Description                                      │\n├──────────┼─────────────┼──────────────────────────────────────────────────┤\n│ X        │ xᵢ          │ Position [n_particles, 2]                        │\n│ V        │ vᵢ          │ Velocity [n_particles, 2]                        │\n│ C        │ Cᵢ          │ Affine velocity matrix [n_particles, 2, 2]       │\n│ F        │ Fᵢ          │ Deformation gradient [n_particles, 2, 2]         │\n│ Jp       │ Jₚ          │ Plastic volume ratio [n_particles, 1]            │\n│ T        │ type        │ Material type (0=liquid, 1=jelly, 2=snow)        │\n│ M        │ mᵢ          │ Mass [n_particles, 1]                            │\n└──────────┴─────────────┴──────────────────────────────────────────────────┘\n\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 1: DEFORMATION GRADIENT UPDATE                                      ║\n║                                                                           ║\n║    F = (I + dt*C) @ F                                                     ║\n║                                                                           ║\n║  Code: F = (identity + dt * C) @ F                            Line 49    ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 1-&gt;2: MATERIAL-SPECIFIC F REFINEMENT                                │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │  SVD DECOMPOSITION                                                  │  │\n│  │                                                                     │  │\n│  │    F = U * Sigma * V^T                                              │  │\n│  │                                                                     │  │\n│  │  Code: U, sig, Vh = torch.linalg.svd(F_reg)            Line 64     │  │\n│  │                                                                     │  │\n│  │  Variables:                                                         │  │\n│  │    U, Vh  -&gt; rotation matrices [n_particles, 2, 2]                  │  │\n│  │    sig    -&gt; singular values (stretches) [n_particles, 2]           │  │\n│  │    J      -&gt; det(F) = sig1*sig2 = torch.prod(sig)                   │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                    │                                      │\n│      ┌─────────────────────────────┼─────────────────────────────┐        │\n│      ▼                             ▼                             ▼        │\n│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐  │\n│  │    LIQUID     │          │     JELLY     │          │     SNOW      │  │\n│  │   (T == 0)    │          │   (T == 1)    │          │   (T == 2)    │  │\n│  ├───────────────┤          ├───────────────┤          ├───────────────┤  │\n│  │ mu = 0        │          │ h = 0.3       │          │ h = exp(10*   │  │\n│  │ (no shear)    │          │ (constant)    │          │    (1-Jp))    │  │\n│  │               │          │               │          │               │  │\n│  │ F = sqrt(J)*I │          │ sig clamped   │          │ sig clamped   │  │\n│  │ (isotropic)   │          │ F = U*Sig*V^T │          │ [0.975,1.0045]│  │\n│  │               │          │               │          │ Jp updated    │  │\n│  └───────────────┘          └───────────────┘          └───────────────┘  │\n│      │                             │                             │        │\n│      └─────────────────────────────┼─────────────────────────────┘        │\n│                                    ▼                                      │\n│  Code references:                                                         │\n│    - Hardening: h = torch.exp(10 * (1.0 - Jp.squeeze()))      Line 51    │\n│    - Jelly h:   h = torch.where(jelly_mask, 0.3, h)           Line 52    │\n│    - Lame:      mu = mu_0 * h, la = lambda_0 * h              Lines 55-56│\n│    - Liquid mu: mu = torch.where(liquid_mask, 0.0, mu)        Line 57    │\n│    - Snow clamp: sig = torch.clamp(sig, 1-2.5e-2, 1+4.5e-3)   Line 98    │\n│    - Jp update: Jp = Jp * plastic_ratio                       Line 102   │\n│    - Liquid F:  F_liquid = identity * sqrt(J)                 Line 112   │\n│    - Solid F:   F_solid = U @ sig_diag @ Vh                   Line 113   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 2: STRESS COMPUTATION                                               ║\n║                                                                           ║\n║    R = U * V^T                   (rotation component)                     ║\n║                                                                           ║\n║    stress = 2*mu*(F-R)*F^T + la*J*(J-1)*I   (Cauchy, corotated model)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    R = U @ Vh                                                 Line 123   ║\n║    F_minus_R = F - R                                          Line 124   ║\n║    stress = (2*mu*(F-R)@F^T + la*J*(J-1)*I)                  Line 125-126║\n║    stress = (-dt * p_vol * 4 * inv_dx^2) * stress            Line 127    ║\n║                                                                           ║\n║  The scaling factor converts stress to force for P2G transfer             ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 2-&gt;3: AFFINE MOMENTUM COMPUTATION                                   │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │                                                                     │  │\n│  │     affine = stress + m * C                                         │  │\n│  │                                                                     │  │\n│  │  Code: affine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C    │  │\n│  │                                                        Line 162    │  │\n│  │                                                                     │  │\n│  │  Physical interpretation:                                           │  │\n│  │    - stress term: internal forces from deformation                  │  │\n│  │    - m*C term: momentum transport (APIC angular momentum)           │  │\n│  │                                                                     │  │\n│  │  This combined \"affine\" carries BOTH force AND momentum info        │  │\n│  │  to the grid in a single transfer.                                  │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                                                           │\n│  Variables at this point:                                                 │\n│  ┌────────────┬─────────────┬────────────────────────────────────────┐   │\n│  │ Variable   │ Shape       │ Description                            │   │\n│  ├────────────┼─────────────┼────────────────────────────────────────┤   │\n│  │ stress     │ [N, 2, 2]   │ Scaled stress (force)                  │   │\n│  │ C          │ [N, 2, 2]   │ Affine velocity matrix                 │   │\n│  │ p_mass     │ [N]         │ Particle mass                          │   │\n│  │ affine     │ [N, 2, 2]   │ Combined force + momentum gradient     │   │\n│  └────────────┴─────────────┴────────────────────────────────────────┘   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 3: P2G TRANSFER (Particle to Grid)                                  ║\n║                                                                           ║\n║  Each particle i CONTRIBUTES to its 9 neighboring grid nodes j:           ║\n║                                                                           ║\n║    contribution to mass:     dm_j = w_j * m_i                             ║\n║    contribution to momentum: dp_j = w_j * (m_i*v_i + Q_i*(x_j - x_i))     ║\n║                                                                           ║\n║  The GNN ACCUMULATES all particle contributions at each grid node:        ║\n║                                                                           ║\n║    m_j = SUM_i dm_j   (total mass at node j)                              ║\n║    p_j = SUM_i dp_j   (total momentum at node j)                          ║\n║                                                                           ║\n║  Code (MPM_P2G.message computes d, GNN aggregation computes SUM):         ║\n║    out_m = mass_j * weights              # dm_j contribution              ║\n║    out_v = weights * (m*v + Q @ dpos)    # dp_j contribution              ║\n║                                                                           ║\n║  After GNN aggregation (Line 214-216):                                    ║\n║    grid_m = accumulated mass m_j     [n_grid, n_grid]                     ║\n║    grid_v = accumulated momentum p_j [n_grid, n_grid, 2] (NOT velocity!)  ║\n║                                                                           ║\n║  Weights: Quadratic B-spline w0, w1, w2                     Lines 178-181 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 4: GRID OPERATIONS                                                  ║\n║                                                                           ║\n║    v_j = p_j / m_j               (momentum -&gt; velocity, using accumulated)║\n║    v_j += dt * g                 (gravity)                                ║\n║    Apply boundary conditions     (friction, no-penetration)               ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    grid_v = grid_v / (grid_m + eps)                         Line 226-228  ║\n║    grid_v = grid_v + gravity_force                          Line 232-234  ║\n║    Boundary handling                                        Lines 242-266 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 5: G2P TRANSFER                                                     ║\n║                                                                           ║\n║    v_i = SUM_j w_j * v_j              (APIC velocity update)              ║\n║                                                                           ║\n║    C_i = 4/dx^2 * SUM_j w_j * v_j (x) (x_j - x_i)   (affine velocity)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    new_V = SUM weights * g_v_all                            Line 304-305  ║\n║    outer_products = g_v @ dpos^T                            Line 309-311  ║\n║    new_C = 4 * inv_dx * SUM weights * outer_products        Line 315      ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 6: ADVECTION                                                        ║\n║                                                                           ║\n║    x_i = x_i + dt * v_i                                                   ║\n║                                                                           ║\n║  Code: X = X + dt * new_V                                       Line 322  ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                    │\n                                    ▼\nOUTPUT STATE: X, V, C, F, Jp (updated)"
  },
  {
    "objectID": "variable-schematic.html#variable-reference-table",
    "href": "variable-schematic.html#variable-reference-table",
    "title": "Variable Schematic",
    "section": "Variable Reference Table",
    "text": "Variable Reference Table\n\n\n\n\n\n\n\n\n\n\nCode Variable\nMath Symbol\nShape\nPhysical Meaning\nUnits\n\n\n\n\nX\n\\(\\mathbf{x}_i\\)\n[N, 2]\nParticle position\nm\n\n\nV\n\\(\\mathbf{v}_i\\)\n[N, 2]\nParticle velocity\nm/s\n\n\nC\n\\(\\mathbf{C}_i\\)\n[N, 2, 2]\nAffine velocity matrix (velocity gradient)\n1/s\n\n\nF\n\\(\\mathbf{F}_i\\)\n[N, 2, 2]\nDeformation gradient\n-\n\n\nJp\n\\(J_p\\)\n[N, 1]\nPlastic volume ratio (accumulated)\n-\n\n\nT\ntype\n[N, 1]\nMaterial type index\n-\n\n\nM\n\\(m_i\\)\n[N, 1]\nParticle mass\nkg\n\n\nU\n\\(\\mathbf{U}\\)\n[N, 2, 2]\nLeft rotation (from SVD)\n-\n\n\nsig\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2]\nSingular values (stretches)\n-\n\n\nVh\n\\(\\mathbf{V}^T\\)\n[N, 2, 2]\nRight rotation transposed\n-\n\n\nR\n\\(\\mathbf{R}\\)\n[N, 2, 2]\nRotation matrix \\(\\mathbf{U}\\mathbf{V}^T\\)\n-\n\n\nJ\n\\(J\\)\n[N]\nVolume ratio \\(\\det(\\mathbf{F})\\)\n-\n\n\nh\n\\(h\\)\n[N]\nHardening factor\n-\n\n\nmu\n\\(\\mu\\)\n[N]\nShear modulus\nPa\n\n\nla\n\\(\\lambda\\)\n[N]\nFirst Lame parameter\nPa\n\n\nstress\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2, 2]\nCauchy stress (scaled)\nN\n\n\naffine\n\\(\\mathbf{Q}\\)\n[N, 2, 2]\nAffine momentum \\(\\sigma + m\\mathbf{C}\\)\nN\n\n\ngrid_m\n\\(m_j\\)\n[G, G]\nGrid mass (accumulated)\nkg\n\n\ngrid_v\n\\(\\mathbf{p}_j\\)\n[G, G, 2]\nGrid momentum (accumulated, NOT velocity!)\nkg·m/s\n\n\nw\n\\(w\\)\n[N, 3, 2]\nB-spline weights\n-"
  },
  {
    "objectID": "variable-schematic.html#key-equations-summary",
    "href": "variable-schematic.html#key-equations-summary",
    "title": "Variable Schematic",
    "section": "Key Equations Summary",
    "text": "Key Equations Summary\n\nDeformation Update\n\\[\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\mathbf{F}^n\\]\n\n\nSVD Decomposition\n\\[\\mathbf{F} = \\mathbf{U} \\, \\text{diag}(\\sigma_1, \\sigma_2) \\, \\mathbf{V}^T\\]\n\n\nHardening (Snow)\n\\[h = \\exp\\bigl(10(1 - J_p)\\bigr)\\]\n\n\nLame Parameters\n\\[\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\\]\n\n\nCauchy Stress (Fixed Corotated)\n\\[\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\\]\n\n\nAffine Momentum\n\\[\\mathbf{Q} = \\boldsymbol{\\sigma}_{\\text{scaled}} + m \\, \\mathbf{C}\\]\n\n\nP2G Transfer\nStep 1: Each particle contributes to neighboring grid nodes \\[\\delta m_j = w_j \\, m_i, \\quad \\delta \\mathbf{p}_j = w_j \\bigl(m_i \\mathbf{v}_i + \\mathbf{Q} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)\\bigr)\\]\nStep 2: GNN accumulates all contributions at each node \\[m_j = \\sum_i \\delta m_j, \\quad \\mathbf{p}_j = \\sum_i \\delta \\mathbf{p}_j\\]\n\n\nGrid Operations (uses accumulated values)\n\\[\\mathbf{v}_j = \\mathbf{p}_j / m_j \\quad \\text{(momentum} \\to \\text{velocity)}\\]\n\n\nG2P Transfer (APIC)\n\\[\\mathbf{v}_i = \\sum_j w_j \\, \\mathbf{v}_j, \\quad \\mathbf{C}_i = \\frac{4}{\\Delta x^2} \\sum_j w_j \\, \\mathbf{v}_j \\otimes (\\mathbf{x}_j - \\mathbf{x}_i)\\]\n\n\nAdvection\n\\[\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\Delta t \\, \\mathbf{v}^{n+1}\\]"
  },
  {
    "objectID": "variable-schematic.html#the-affine-term-explained",
    "href": "variable-schematic.html#the-affine-term-explained",
    "title": "Variable Schematic",
    "section": "The Affine Term Explained",
    "text": "The Affine Term Explained\nThe key insight is that affine = stress + m·C combines two physical effects:\n\n\n\n\n\n\nImportantWhy stress + m·C?\n\n\n\n\nstress term: Internal forces from material deformation. This is what creates elastic/plastic behavior.\nm·C term: The APIC (Affine Particle-In-Cell) contribution. This preserves angular momentum and prevents numerical dissipation.\n\nEach particle’s contribution to grid momentum is: \\[\\delta \\mathbf{p}_j = w_j \\cdot \\bigl[\\underbrace{m_i \\mathbf{v}_i}_{\\text{linear momentum}} + \\underbrace{\\mathbf{Q}}_{\\text{affine}} \\cdot \\underbrace{(\\mathbf{x}_j - \\mathbf{x}_i)}_{\\text{dpos}}\\bigr]\\]\nThis single transfer carries both force (from stress) and momentum gradient (from C) information."
  },
  {
    "objectID": "variable-schematic.html#material-specific-behavior",
    "href": "variable-schematic.html#material-specific-behavior",
    "title": "Variable Schematic",
    "section": "Material-Specific Behavior",
    "text": "Material-Specific Behavior\n                    ┌─────────────┐\n                    │   F update  │\n                    │ F=(I+dt·C)F │\n                    └──────┬──────┘\n                           │\n                    ┌──────▼──────┐\n                    │     SVD     │\n                    │  F = UΣVᵀ   │\n                    └──────┬──────┘\n                           │\n         ┌─────────────────┼─────────────────┐\n         ▼                 ▼                 ▼\n   ┌───────────┐    ┌───────────┐    ┌───────────┐\n   │  LIQUID   │    │   JELLY   │    │   SNOW    │\n   │  (T=0)    │    │   (T=1)   │    │   (T=2)   │\n   ├───────────┤    ├───────────┤    ├───────────┤\n   │ μ = 0     │    │ h = 0.3   │    │ h=e^10(1-Jp)\n   │           │    │ μ = μ₀·h  │    │ μ = μ₀·h  │\n   │ F = √J·I  │    │ F = UΣVᵀ  │    │ Σ clamped │\n   │(isotropic)│    │           │    │ Jp updated│\n   │           │    │           │    │ F = UΣ'Vᵀ │\n   └─────┬─────┘    └─────┬─────┘    └─────┬─────┘\n         │                │                │\n         └────────────────┼────────────────┘\n                          ▼\n                   ┌─────────────┐\n                   │   Stress    │\n                   │ σ=2μ(F-R)Fᵀ │\n                   │  +λJ(J-1)I  │\n                   └──────┬──────┘\n                          ▼\n                   ┌─────────────┐\n                   │   Affine    │\n                   │  Q = σ + mC │\n                   └──────┬──────┘\n                          ▼\n                      P2G transfer"
  },
  {
    "objectID": "mpm-algorithm.html",
    "href": "mpm-algorithm.html",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#algorithm-overview",
    "href": "mpm-algorithm.html#algorithm-overview",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "href": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "title": "MPM Algorithm",
    "section": "Phase 1: Deformation Gradient Update",
    "text": "Phase 1: Deformation Gradient Update\nThe deformation gradient \\(\\mathbf{F}\\) tracks how material has deformed from its rest configuration.\n\nUpdate Rule\nUsing the Moving Least Squares (MLS) approximation:\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\nwhere \\(\\mathbf{C}_i\\) is the affine velocity matrix capturing local velocity gradients.\n\n\nSVD Decomposition\nFor plasticity and stability, we decompose:\n\\[\n\\mathbf{F}_i = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\nwhere: - \\(\\mathbf{U}, \\mathbf{V}\\) are rotation matrices - \\(\\boldsymbol{\\Sigma} = \\text{diag}(\\sigma_1, \\sigma_2)\\) contains singular values (stretches)\n\n\n\n\n\n\nNoteImplementation Note\n\n\n\nThe code uses torch.linalg.svd with sign corrections to ensure proper rotation matrices (det = +1)."
  },
  {
    "objectID": "mpm-algorithm.html#phase-2-stress-computation",
    "href": "mpm-algorithm.html#phase-2-stress-computation",
    "title": "MPM Algorithm",
    "section": "Phase 2: Stress Computation",
    "text": "Phase 2: Stress Computation\n\nHardening Factor\nMaterial stiffness varies with plastic deformation:\n\\[\nh = \\exp(10(1 - J_p))\n\\]\n\n\\(J_p &lt; 1\\) (compression): \\(h &gt; 1\\) (hardening)\n\\(J_p &gt; 1\\) (expansion): \\(h &lt; 1\\) (softening)\n\n\n\nLame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\n\nParameter\nSymbol\nPhysical Meaning\n\n\n\n\n\\(\\mu\\)\nShear modulus\nResistance to shape change\n\n\n\\(\\lambda\\)\nFirst Lame parameter\nResistance to volume change\n\n\n\n\n\nCauchy Stress\nThe fixed corotated hyperelastic model:\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere: - \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation component - \\(J = \\det(\\mathbf{F}) = \\sigma_1 \\cdot \\sigma_2\\) is the volume ratio"
  },
  {
    "objectID": "mpm-algorithm.html#phase-3-p2g-transfer",
    "href": "mpm-algorithm.html#phase-3-p2g-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 3: P2G Transfer",
    "text": "Phase 3: P2G Transfer\nTransfer particle quantities to the background grid using quadratic B-spline weights.\n\nBase Index\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i / \\Delta x - 0.5 \\rfloor\n\\]\n\n\nB-Spline Weights\nFor fractional position \\(\\mathbf{f}_x = \\mathbf{x}_i / \\Delta x - \\mathbf{j}_{\\text{base}}\\):\n\\[\n\\begin{aligned}\nw_0 &= 0.5(1.5 - f_x)^2 \\\\\nw_1 &= 0.75 - (f_x - 1)^2 \\\\\nw_2 &= 0.5(f_x - 0.5)^2\n\\end{aligned}\n\\]\n\n\nMomentum Transfer\nFor each of the 9 neighboring grid nodes (in 2D):\n\\[\n\\Delta \\mathbf{m}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) \\right)\n\\]\nwhere \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum."
  },
  {
    "objectID": "mpm-algorithm.html#phase-4-grid-operations",
    "href": "mpm-algorithm.html#phase-4-grid-operations",
    "title": "MPM Algorithm",
    "section": "Phase 4: Grid Operations",
    "text": "Phase 4: Grid Operations\n\nMomentum to Velocity\n\\[\n\\mathbf{v}_{\\mathbf{j}} = \\frac{\\mathbf{m}_{\\mathbf{j}}}{m_{\\mathbf{j}}}\n\\]\n\n\nGravity\n\\[\n\\mathbf{v}_{\\mathbf{j}} \\leftarrow \\mathbf{v}_{\\mathbf{j}} + \\Delta t \\, \\mathbf{g}\n\\]\n\n\nBoundary Conditions\n\nNormal: Set penetrating velocity to zero\nTangential: Apply friction: \\(\\mathbf{v}_t \\leftarrow (1-\\alpha) \\mathbf{v}_t\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-5-g2p-transfer",
    "href": "mpm-algorithm.html#phase-5-g2p-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 5: G2P Transfer",
    "text": "Phase 5: G2P Transfer\n\nVelocity Update (APIC)\n\\[\n\\mathbf{v}_i^{n+1} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}}\n\\]\n\n\nAffine Velocity Update\n\\[\n\\mathbf{C}_i^{n+1} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}} \\otimes (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\n\\]\nThe outer product captures local velocity gradients."
  },
  {
    "objectID": "mpm-algorithm.html#phase-6-advection",
    "href": "mpm-algorithm.html#phase-6-advection",
    "title": "MPM Algorithm",
    "section": "Phase 6: Advection",
    "text": "Phase 6: Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "mpm-algorithm.html#complete-algorithm",
    "href": "mpm-algorithm.html#complete-algorithm",
    "title": "MPM Algorithm",
    "section": "Complete Algorithm",
    "text": "Complete Algorithm\nAlgorithm: MPM Time Step\n────────────────────────────────────────────────\nInput: Particle states {x, v, C, F, Jp, m, T}\n       Grid parameters: n_grid, dx, dt\n       Material parameters: mu_0, lambda_0\n\n1. FOR each particle i:\n   │  F ← (I + dt*C) @ F\n   │  U, Σ, V^T ← SVD(F)\n   │\n   │  IF snow: clamp Σ, update Jp\n   │  IF liquid: F ← sqrt(J)*I\n   │\n   │  Compute stress σ\n   │  Q ← stress + m*C\n   └\n\n2. P2G: Clear grid, scatter particle contributions\n   FOR each particle i:\n   │  FOR each neighbor j ∈ N(i):\n   │  │  m_j += w_j * m_i\n   │  │  mv_j += w_j * (m_i*v_i + Q*(x_j - x_i))\n   └  └\n\n3. Grid: Apply physics\n   FOR each grid node j with m_j &gt; 0:\n   │  v_j ← mv_j / m_j + dt*g\n   │  Apply boundary conditions\n   └\n\n4. G2P: Gather grid velocities\n   FOR each particle i:\n   │  v_new ← Σ w_j * v_j\n   │  C_new ← 4/dx² * Σ w_j * v_j ⊗ (x_j - x_i)\n   │  x ← x + dt * v_new\n   └\n\nOutput: Updated particle states\n────────────────────────────────────────────────"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MPM PyTorch",
    "section": "",
    "text": "The Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches.\nThis implementation provides a fully differentiable MPM solver in PyTorch, enabling:\n\nForward simulation of multi-material interactions (liquids, solids, snow)\nInverse problems through automatic differentiation\nNeural network integration via Graph Neural Networks for P2G transfer"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "MPM PyTorch",
    "section": "",
    "text": "The Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches.\nThis implementation provides a fully differentiable MPM solver in PyTorch, enabling:\n\nForward simulation of multi-material interactions (liquids, solids, snow)\nInverse problems through automatic differentiation\nNeural network integration via Graph Neural Networks for P2G transfer"
  },
  {
    "objectID": "index.html#hybrid-lagrangian-eulerian-approach",
    "href": "index.html#hybrid-lagrangian-eulerian-approach",
    "title": "MPM PyTorch",
    "section": "Hybrid Lagrangian-Eulerian Approach",
    "text": "Hybrid Lagrangian-Eulerian Approach\nMPM uses a hybrid approach where:\n\nParticles carry material state (mass, velocity, deformation history)\nGrid handles momentum transfer and boundary conditions\n\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\nDeformation gradient update: \\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nCauchy stress from constitutive model\n\n\n3\nP2G Transfer\nScatter mass & momentum to grid\n\n\n4\nGrid Operations\nApply gravity, boundary conditions\n\n\n5\nG2P Transfer\nGather velocities back to particles\n\n\n6\nAdvect\nUpdate particle positions: \\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)\n\n\n\nThe cycle repeats for each timestep."
  },
  {
    "objectID": "index.html#particle-state-variables",
    "href": "index.html#particle-state-variables",
    "title": "MPM PyTorch",
    "section": "Particle State Variables",
    "text": "Particle State Variables\nEach particle \\(i\\) carries the following quantities:\n\n\n\n\n\n\n\n\n\nSymbol\nVariable\nDimension\nDescription\n\n\n\n\n\\(\\mathbf{x}_i\\)\nPosition\n\\(d\\)\nSpatial location (2D or 3D)\n\n\n\\(\\mathbf{v}_i\\)\nVelocity\n\\(d\\)\nMaterial velocity\n\n\n\\(\\mathbf{C}_i\\)\nAffine velocity\n\\(d \\times d\\)\nLocal velocity gradient (APIC)\n\n\n\\(\\mathbf{F}_i\\)\nDeformation gradient\n\\(d \\times d\\)\nTracks total deformation\n\n\n\\(J_i\\)\nPlastic deformation\n\\(1\\)\nAccumulated plastic volume change\n\n\n\\(m_i\\)\nMass\n\\(1\\)\nParticle mass\n\n\n\\(T_i\\)\nMaterial type\n\\(1\\)\n0=liquid, 1=jelly, 2=snow"
  },
  {
    "objectID": "index.html#material-types",
    "href": "index.html#material-types",
    "title": "MPM PyTorch",
    "section": "Material Types",
    "text": "Material Types\nMPM PyTorch supports three material types with distinct behaviors:\n\nLiquidJelly (Elastic Solid)Snow\n\n\n\nNo shear resistance (\\(\\mu = 0\\))\nIsotropic deformation: \\(\\mathbf{F} = \\sqrt{J} \\, \\mathbf{I}\\)\nOptional surface tension\n\n\n\n\nFixed stiffness (\\(h = 0.3\\))\nFull elastic response\nPreserves shape memory\n\n\n\n\nPlastic deformation with clamped singular values\nHardening/softening based on \\(J_p\\)\nCaptures compression and fracture"
  },
  {
    "objectID": "index.html#key-equations",
    "href": "index.html#key-equations",
    "title": "MPM PyTorch",
    "section": "Key Equations",
    "text": "Key Equations\n\nDeformation Gradient Update\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\n\n\nCauchy Stress (Neo-Hookean)\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation from SVD of \\(\\mathbf{F}\\).\n\n\nParticle Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "index.html#d-simulation-gallery",
    "href": "index.html#d-simulation-gallery",
    "title": "MPM PyTorch",
    "section": "2D Simulation Gallery",
    "text": "2D Simulation Gallery\n\nMulti-Material (3 types)CollisionPincerCells\n\n\n9 discs of different materials (liquid, jelly, snow) falling under gravity.\n\n\n\nTwo discs of different materials colliding.\n\n\n\nLiquid and jelly discs squeezing a center jelly disc.\n\n\n\nSoft cell-like bodies with expansion, simulating biological tissue."
  },
  {
    "objectID": "index.html#d-simulation-gallery-1",
    "href": "index.html#d-simulation-gallery-1",
    "title": "MPM PyTorch",
    "section": "3D Simulation Gallery",
    "text": "3D Simulation Gallery\n\nFalling Cubes\n\n\n27 cubes of particles falling in a 3D box (35,937 particles on 128x128x128 grid)."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "MPM PyTorch",
    "section": "Documentation",
    "text": "Documentation\n\n\n\nPage\nContent\n\n\n\n\nMPM Algorithm\nComplete algorithm overview\n\n\nP2G & G2P Transfers\nParticle-grid interpolation\n\n\nMaterial Types\nLiquid, jelly, snow behaviors\n\n\nConstitutive Models\nStress computation\n\n\nImplementation\nCode walkthrough"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "MPM PyTorch",
    "section": "References",
    "text": "References\n\nStomakhin et al. (2013). “A material point method for snow simulation”\nHu et al. (2018). “A moving least squares material point method with displacement discontinuity and two-way rigid body coupling”\nJiang et al. (2015). “The affine particle-in-cell method”"
  },
  {
    "objectID": "constitutive.html",
    "href": "constitutive.html",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#overview",
    "href": "constitutive.html#overview",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#deformation-gradient",
    "href": "constitutive.html#deformation-gradient",
    "title": "Constitutive Models",
    "section": "Deformation Gradient",
    "text": "Deformation Gradient\nThe deformation gradient \\(\\mathbf{F}\\) is a \\(d \\times d\\) matrix (2×2 in 2D) that maps from reference to deformed configuration:\n\\[\nd\\mathbf{x} = \\mathbf{F} \\cdot d\\mathbf{X}\n\\]\n\nUpdate Rule\n\\[\n\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\, \\mathbf{F}^n\n\\]\nwhere \\(\\mathbf{C}\\) is the affine velocity matrix (velocity gradient).\n\n\nSVD Decomposition\nFor stress computation and plasticity:\n\\[\n\\mathbf{F} = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\n\n\n\nComponent\nSize\nInterpretation\n\n\n\n\n\\(\\mathbf{U}\\)\n\\(d \\times d\\)\nLeft rotation\n\n\n\\(\\boldsymbol{\\Sigma}\\)\n\\(d \\times d\\)\nStretch (diagonal)\n\n\n\\(\\mathbf{V}^T\\)\n\\(d \\times d\\)\nRight rotation\n\n\n\n\n\nKey Quantities\n\n\n\nSymbol\nFormula\nMeaning\n\n\n\n\n\\(J\\)\n\\(\\det(\\mathbf{F}) = \\prod_k \\sigma_k\\)\nVolume ratio\n\n\n\\(\\mathbf{R}\\)\n\\(\\mathbf{U}\\mathbf{V}^T\\)\nRotation component"
  },
  {
    "objectID": "constitutive.html#fixed-corotated-model",
    "href": "constitutive.html#fixed-corotated-model",
    "title": "Constitutive Models",
    "section": "Fixed Corotated Model",
    "text": "Fixed Corotated Model\nThe stress depends on how much \\(\\mathbf{F}\\) deviates from a pure rotation.\n\nFirst Piola-Kirchhoff Stress\n\\[\n\\mathbf{P} = 2\\mu (\\mathbf{F} - \\mathbf{R}) + \\lambda (J - 1) J \\mathbf{F}^{-T}\n\\]\n\n\nCauchy Stress (Used in Code)\n\\[\n\\boldsymbol{\\sigma} = \\frac{1}{J} \\mathbf{P} \\mathbf{F}^T = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\n\n\nComponents\n\n\n\n\n\n\n\nTerm\nPhysical Meaning\n\n\n\n\n\\(2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T\\)\nShear resistance (shape recovery)\n\n\n\\(\\lambda J (J-1) \\mathbf{I}\\)\nBulk resistance (volume recovery)\n\n\n\n\n\n\n\n\n\nNoteWhy “Corotated”?\n\n\n\nThe model measures deformation relative to the rotation \\(\\mathbf{R}\\), making it frame-invariant and stable under large rotations."
  },
  {
    "objectID": "constitutive.html#hardening-model",
    "href": "constitutive.html#hardening-model",
    "title": "Constitutive Models",
    "section": "Hardening Model",
    "text": "Hardening Model\nMaterial stiffness varies with plastic history through the hardening factor \\(h\\):\n\\[\nh = \\exp(10 (1 - J_p))\n\\]\n\nEffect on Lame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\nPhysical Interpretation\n\n\n\nState\n\\(J_p\\)\n\\(h\\)\nMaterial\n\n\n\n\nCompressed\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nStiffer\n\n\nReference\n\\(= 1\\)\n\\(= 1\\)\nNormal\n\n\nExpanded\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nSofter"
  },
  {
    "objectID": "constitutive.html#plasticity-snow-only",
    "href": "constitutive.html#plasticity-snow-only",
    "title": "Constitutive Models",
    "section": "Plasticity (Snow Only)",
    "text": "Plasticity (Snow Only)\nSnow undergoes irreversible plastic deformation when stretched or compressed beyond limits.\n\nYield Surface\nThe singular values are constrained:\n\\[\n\\sigma_k \\in [1 - \\epsilon_c, 1 + \\epsilon_s]\n\\]\n\n\n\nParameter\nValue\nMeaning\n\n\n\n\n\\(\\epsilon_c\\)\n0.025\nCompression limit\n\n\n\\(\\epsilon_s\\)\n0.0045\nStretch limit\n\n\n\n\n\nPlastic Flow\nWhen singular values exceed limits:\n\nClamp to valid range: \\(\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, ...)\\)\nUpdate plastic deformation: \\(J_p \\leftarrow J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\\)\nReconstruct: \\(\\mathbf{F} \\leftarrow \\mathbf{U} \\, \\text{diag}(\\sigma_k^{\\text{new}}) \\, \\mathbf{V}^T\\)"
  },
  {
    "objectID": "constitutive.html#stress-scaling-for-mpm",
    "href": "constitutive.html#stress-scaling-for-mpm",
    "title": "Constitutive Models",
    "section": "Stress Scaling for MPM",
    "text": "Stress Scaling for MPM\nThe stress is scaled for P2G momentum transfer:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\n\nAffine Momentum\nThe final quantity transferred to grid:\n\\[\n\\mathbf{Q} = \\text{stress} + m \\, \\mathbf{C}\n\\]"
  },
  {
    "objectID": "constitutive.html#implementation",
    "href": "constitutive.html#implementation",
    "title": "Constitutive Models",
    "section": "Implementation",
    "text": "Implementation\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F_reg)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)))\n\n# Scale for P2G\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass * C"
  },
  {
    "objectID": "constitutive.html#energy-density",
    "href": "constitutive.html#energy-density",
    "title": "Constitutive Models",
    "section": "Energy Density",
    "text": "Energy Density\nThe stored elastic energy (for reference):\n\\[\n\\Psi = \\mu \\|\\mathbf{F} - \\mathbf{R}\\|_F^2 + \\frac{\\lambda}{2}(J-1)^2\n\\]\nThis energy is minimized when: - \\(\\mathbf{F} = \\mathbf{R}\\) (pure rotation, no stretch) - \\(J = 1\\) (no volume change)"
  },
  {
    "objectID": "implementation.html",
    "href": "implementation.html",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#code-structure",
    "href": "implementation.html#code-structure",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#key-files",
    "href": "implementation.html#key-files",
    "title": "Implementation",
    "section": "Key Files",
    "text": "Key Files\n\nMPM_step.py - Core Algorithm\nThe heart of the simulation. Contains:\n\nMPM_step(): Complete time step\ncompute_surface_tension_stress(): Liquid surface tension\n\n\n\ngraph_data_generator.py - Simulation Runner\nOrchestrates the full simulation:\n\ndata_generate_MPM_2D(): 2D simulation loop\nInitialization of particle states\nFrame-by-frame stepping\nVisualization output"
  },
  {
    "objectID": "implementation.html#mpm-step-implementation",
    "href": "implementation.html#mpm-step-implementation",
    "title": "Implementation",
    "section": "MPM Step Implementation",
    "text": "MPM Step Implementation\n\nFunction Signature\ndef MPM_step(\n    model_MPM,      # GNN model for P2G\n    X, V, C, F, Jp, T, M,  # Particle states\n    n_particles, n_grid,   # Dimensions\n    dt, dx, inv_dx,        # Time/space steps\n    mu_0, lambda_0,        # Material parameters\n    p_vol, offsets, particle_offsets,\n    expansion_factor, gravity, friction,\n    frame,\n    surface_tension_coeff, tension_scaling,\n    enable_surface_tension, debug_surface,\n    device\n):\n\n\nPhase 1: Deformation Update\n# Material masks\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)\n\n# Update deformation gradient\nidentity = torch.eye(2, device=device).unsqueeze(0)\nF = (identity + dt * C) @ F\n\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\nh = torch.where(jelly_mask, 0.3, h)  # Fixed for jelly\n\n# Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\nmu = torch.where(liquid_mask, 0.0, mu)  # No shear for liquid\n\n\nPhase 2: SVD and Plasticity\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F + 1e-6 * identity)\n\n# Sign corrections for proper rotations\ndet_U = torch.det(U)\nneg_det_U = det_U &lt; 0\nif neg_det_U.any():\n    U[neg_det_U, :, -1] *= -1\n    sig[neg_det_U, -1] *= -1\n\n# Snow plasticity: clamp singular values\nsig = torch.where(\n    snow_mask.unsqueeze(1),\n    torch.clamp(sig, min=1-2.5e-2, max=1+4.5e-3),\n    sig\n)\n\n# Update plastic deformation\nJp = Jp * torch.prod(original_sig / sig, dim=1, keepdim=True)\n\n\nPhase 3: Stress Computation\n# Volume ratio\nJ = torch.prod(sig, dim=1)\nJ = torch.clamp(J, min=1e-4)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu.unsqueeze(-1).unsqueeze(-1) * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)).unsqueeze(-1).unsqueeze(-1))\n\n# Scale for P2G transfer\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C\n\n\nPhase 4: P2G Transfer\n# Base grid node\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n# Build graph for GNN\ndataset = data.Data(\n    x=x_,\n    edge_index=edge_index,\n    weights_per_edge=weights_per_edge,\n    affine_per_edge=affine_per_edge,\n    dpos_per_edge=dpos_per_edge\n)\n\n# GNN forward pass\ngrid_output = model_MPM(dataset)[0:n_grid**2]\ngrid_m = grid_output[:, 0].view(n_grid, n_grid)\ngrid_v = grid_output[:, 1:3].view(n_grid, n_grid, 2)\n\n\nPhase 5: Grid Operations\n# Momentum to velocity\nvalid_mass_mask = grid_m &gt; 0\ngrid_v = torch.where(\n    valid_mass_mask.unsqueeze(-1),\n    grid_v / (grid_m.unsqueeze(-1) + 1e-10),\n    grid_v\n)\n\n# Apply gravity\ngravity_force = torch.tensor([0.0, dt * gravity], device=device)\ngrid_v = grid_v + gravity_force\n\n# Boundary conditions\ngrid_v[:, :, 0] = torch.where(left_mask & (grid_v[:, :, 0] &lt; 0), 0.0, grid_v[:, :, 0])\ngrid_v[:, :, 0] = torch.where(right_mask & (grid_v[:, :, 0] &gt; 0), 0.0, grid_v[:, :, 0])\n# ... similar for y-component\n\n\nPhase 6: G2P Transfer\n# Gather velocities from 9 neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\ng_v_flat = g_v_all.reshape(-1, 2, 1)\ndpos_flat = dpos_all.reshape(-1, 1, 2)\nouter_products = torch.bmm(g_v_flat, dpos_flat).reshape(n_particles, 9, 2, 2)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)\n\n# Advection\nX = X + dt * new_V"
  },
  {
    "objectID": "implementation.html#data-generation",
    "href": "implementation.html#data-generation",
    "title": "Implementation",
    "section": "Data Generation",
    "text": "Data Generation\n\nInitialization (graph_data_generator.py)\ndef data_generate_MPM_2D(config, ...):\n    # Grid parameters\n    n_grid = simulation_config.n_grid\n    dx, inv_dx = 1 / n_grid, float(n_grid)\n\n    # Material parameters\n    E, nu = 0.1e4 / young_coeff, 0.2\n    mu_0 = E / (2 * (1 + nu))\n    lambda_0 = E * nu / ((1 + nu) * (1 - 2 * nu))\n\n    # Initialize particles\n    N, X, V, C, F, T, Jp, M, S, ID = init_MPM_shapes(...)\n\n    # Simulation loop\n    for frame in range(n_frames):\n        X, V, C, F, Jp, T, M, stress, grid_m, grid_v = MPM_step(\n            model_MPM, X, V, C, F, Jp, T, M,\n            n_particles, n_grid, dt, dx, inv_dx,\n            mu_0, lambda_0, p_vol, offsets, particle_offsets,\n            expansion_factor, gravity, friction, frame,\n            surface_tension_coeff, tension_scaling,\n            enable_surface_tension, debug_surface,\n            device\n        )\n\n        # Save frame data\n        x_list.append(...)"
  },
  {
    "objectID": "implementation.html#configuration",
    "href": "implementation.html#configuration",
    "title": "Implementation",
    "section": "Configuration",
    "text": "Configuration\nExample YAML config:\ndescription: \"Multi-material simulation with 3 types\"\ndataset: \"multimaterial/multimaterial_1_discs_3types\"\n\nsimulation:\n  n_particles: 9600\n  n_particle_types: 3\n  n_grid: 128\n  n_frames: 2000\n  delta_t: 1.0E-4\n\n  # Material parameters\n  MPM_n_objects: 3\n  MPM_object_type: [0, 1, 2]  # liquid, jelly, snow\n  MPM_rho_list: [1000, 1200, 400]\n  MPM_young_coeff: 1.0\n  MPM_gravity: -200\n  MPM_friction: 0.5\n  MPM_expansion_factor: 1.0\n  MPM_surface_tension: 0.0\n\ntraining:\n  n_runs: 1\n  device: auto"
  },
  {
    "objectID": "implementation.html#running-simulations",
    "href": "implementation.html#running-simulations",
    "title": "Implementation",
    "section": "Running Simulations",
    "text": "Running Simulations\n# Generate data\npython run_MPM.py -o generate multimaterial_1_discs_3types\n\n# Train INR model\npython run_MPM.py -o train_INR multimaterial_1_discs_3types\n\n# Claude-guided exploration\npython run_MPM.py -o train_INR_Claude multimaterial_1_discs_3types iterations=100"
  },
  {
    "objectID": "materials.html",
    "href": "materials.html",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#overview",
    "href": "materials.html#overview",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#material-masks",
    "href": "materials.html#material-masks",
    "title": "Material Types",
    "section": "Material Masks",
    "text": "Material Masks\nIn the code, materials are distinguished by type ID:\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)"
  },
  {
    "objectID": "materials.html#liquid-t-0",
    "href": "materials.html#liquid-t-0",
    "title": "Material Types",
    "section": "Liquid (\\(T = 0\\))",
    "text": "Liquid (\\(T = 0\\))\nLiquids are incompressible fluids with no resistance to shear deformation.\n\nProperties\n\nShear modulus: \\(\\mu = 0\\)\nDeformation: Isotropic only\n\n\n\nDeformation Gradient\nFor liquids, the deformation gradient is reset to preserve only volume:\n\\[\n\\mathbf{F}^{\\text{liquid}} = \\sqrt{J} \\cdot \\mathbf{I}\n\\]\nwhere \\(J = \\det(\\mathbf{F})\\) is the volume ratio.\n\n\n\n\n\n\nNotePhysical Interpretation\n\n\n\nThis ensures liquids have no “shape memory”—they flow to fill any container while preserving volume (incompressibility).\n\n\n\n\nSurface Tension (Optional)\nWhen enabled, surface tension creates cohesive forces between liquid particles:\n\\[\n\\boldsymbol{\\sigma}_{\\text{surface}} = -\\gamma \\cdot s \\cdot (\\mathbf{n} \\otimes \\mathbf{n})\n\\]\nwhere: - \\(\\gamma\\) is the surface tension coefficient - \\(s\\) measures how much of a “surface particle” each particle is - \\(\\mathbf{n}\\) is the direction toward the local center of mass"
  },
  {
    "objectID": "materials.html#jelly-t-1",
    "href": "materials.html#jelly-t-1",
    "title": "Material Types",
    "section": "Jelly (\\(T = 1\\))",
    "text": "Jelly (\\(T = 1\\))\nJelly represents elastic solids that deform and return to their original shape.\n\nProperties\n\nHardening factor: Fixed at \\(h = 0.3\\) (70% softer than reference)\nFull elastic response: Both shear and bulk resistance\n\n\n\nStress Response\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nThe rotation \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is extracted from SVD of \\(\\mathbf{F}\\).\n\n\n\n\n\n\nTipJelly Behavior\n\n\n\n\nBounces back after deformation\nPreserves shape memory\nNo permanent (plastic) deformation"
  },
  {
    "objectID": "materials.html#snow-t-2",
    "href": "materials.html#snow-t-2",
    "title": "Material Types",
    "section": "Snow (\\(T = 2\\))",
    "text": "Snow (\\(T = 2\\))\nSnow exhibits elastoplastic behavior with hardening and softening.\n\nPlasticity Model\nThe singular values of \\(\\mathbf{F}\\) are clamped to limit elastic deformation:\n\\[\n\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, 1 - 2.5 \\times 10^{-2}, 1 + 4.5 \\times 10^{-3})\n\\]\n\n\n\nLimit\nValue\nMeaning\n\n\n\n\nLower\n0.975\nMax 2.5% compression before plastic flow\n\n\nUpper\n1.0045\nMax 0.45% stretch before plastic flow\n\n\n\n\n\nPlastic Volume Accumulation\n\\[\nJ_p^{\\text{new}} = J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\n\\]\nThis tracks cumulative plastic deformation.\n\n\nHardening\nThe hardening factor depends on plastic history:\n\\[\nh = \\exp(10 \\cdot (1 - J_p))\n\\]\n\n\n\n\\(J_p\\)\n\\(h\\)\nMaterial State\n\n\n\n\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nCompressed, harder\n\n\n\\(= 1\\)\n\\(= 1\\)\nReference state\n\n\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nExpanded, softer\n\n\n\n\n\nReconstructed Deformation\nAfter plasticity projection:\n\\[\n\\mathbf{F}^{\\text{snow}} = \\mathbf{U} \\cdot \\text{diag}(\\sigma_k^{\\text{new}}) \\cdot \\mathbf{V}^T\n\\]"
  },
  {
    "objectID": "materials.html#material-parameters",
    "href": "materials.html#material-parameters",
    "title": "Material Types",
    "section": "Material Parameters",
    "text": "Material Parameters\n\nLame Parameters\nFrom Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\):\n\\[\n\\mu_0 = \\frac{E}{2(1+\\nu)}, \\quad \\lambda_0 = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n\\]\n\n\nDefault Values\n\n\n\nParameter\nSymbol\nValue\n\n\n\n\nYoung’s modulus\n\\(E\\)\n\\(10^3\\) Pa\n\n\nPoisson’s ratio\n\\(\\nu\\)\n0.2\n\n\nShear modulus\n\\(\\mu_0\\)\n417 Pa\n\n\nLame first\n\\(\\lambda_0\\)\n278 Pa\n\n\n\n\n\nMaterial-Specific Adjustments\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\n\n# Jelly: fixed softness\nh = torch.where(jelly_mask, 0.3, h)\n\n# Apply to Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\n\n# Liquids: no shear\nmu = torch.where(liquid_mask, 0.0, mu)"
  },
  {
    "objectID": "materials.html#density-and-mass",
    "href": "materials.html#density-and-mass",
    "title": "Material Types",
    "section": "Density and Mass",
    "text": "Density and Mass\nDifferent materials can have different densities:\n# Config example\nsimulation:\n  MPM_rho_list: [1000, 1200, 400]  # [liquid, jelly, snow] kg/m³\nParticle mass is computed as:\n\\[\nm_i = \\rho_{T_i} \\cdot V_p\n\\]\nwhere \\(V_p = (\\Delta x / 2)^2\\) is the particle volume."
  },
  {
    "objectID": "p2g-g2p.html",
    "href": "p2g-g2p.html",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#overview",
    "href": "p2g-g2p.html#overview",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "href": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "title": "P2G & G2P Transfers",
    "section": "Quadratic B-Spline Interpolation",
    "text": "Quadratic B-Spline Interpolation\nEach particle interacts with a 3×3 stencil of neighboring grid nodes (in 2D).\n\nFinding the Base Node\nFor particle at position \\(\\mathbf{x}_i\\):\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i \\cdot n_{\\text{grid}} - 0.5 \\rfloor\n\\]\n\n\nFractional Position\n\\[\n\\mathbf{f}_x = \\mathbf{x}_i \\cdot n_{\\text{grid}} - \\mathbf{j}_{\\text{base}}\n\\]\nThis gives the particle’s position within its local cell, with \\(\\mathbf{f}_x \\in [0.5, 1.5]\\).\n\n\nWeight Functions\nThe quadratic B-spline weights ensure \\(C^1\\) continuity:\n\n\n\nWeight\nFormula\nRange\n\n\n\n\n\\(w_0\\)\n\\(0.5(1.5 - f_x)^2\\)\nNode at base\n\n\n\\(w_1\\)\n\\(0.75 - (f_x - 1)^2\\)\nNode at base+1\n\n\n\\(w_2\\)\n\\(0.5(f_x - 0.5)^2\\)\nNode at base+2\n\n\n\nFor 2D, the combined weight is:\n\\[\nw_{jk} = w_j(f_{x,1}) \\cdot w_k(f_{x,2})\n\\]\n\n\n\n\n\n\nTipProperties of B-Spline Weights\n\n\n\n\nPartition of unity: \\(\\sum_j w_j = 1\\)\nNon-negative: \\(w_j \\geq 0\\)\nCompact support: Only 9 non-zero weights per particle (2D)"
  },
  {
    "objectID": "p2g-g2p.html#p2g-transfer-details",
    "href": "p2g-g2p.html#p2g-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "P2G Transfer Details",
    "text": "P2G Transfer Details\n\nMass Transfer\nEach particle distributes its mass to neighboring nodes:\n\\[\n\\Delta m_{\\mathbf{j}} = w_{\\mathbf{j}} \\cdot m_i\n\\]\n\n\nMomentum Transfer (APIC)\nThe Affine Particle-In-Cell (APIC) method transfers both linear and angular momentum:\n\\[\n\\Delta \\mathbf{p}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nwhere: - \\(\\mathbf{d}_{i\\mathbf{j}} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\\) is the offset vector - \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum matrix\n\n\nStress Contribution\nThe stress tensor is scaled for P2G:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\nwhere \\(V_p\\) is the particle volume."
  },
  {
    "objectID": "p2g-g2p.html#g2p-transfer-details",
    "href": "p2g-g2p.html#g2p-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "G2P Transfer Details",
    "text": "G2P Transfer Details\n\nVelocity Update\n\\[\n\\mathbf{v}_i^{\\text{new}} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}}^{\\text{grid}}\n\\]\n\n\nAffine Velocity Matrix (APIC)\nThe local velocity gradient is reconstructed:\n\\[\n\\mathbf{C}_i^{\\text{new}} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}} \\otimes \\mathbf{d}_{\\mathbf{j}i}\n\\]\nwhere \\(\\mathbf{d}_{\\mathbf{j}i} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) / \\Delta x\\) is the normalized offset.\n\n\n\n\n\n\nNoteWhy APIC?\n\n\n\nThe Affine Particle-In-Cell method: - Conserves angular momentum exactly - Eliminates numerical damping from traditional PIC/FLIP - Provides smoother, more stable simulations"
  },
  {
    "objectID": "p2g-g2p.html#gnn-implementation",
    "href": "p2g-g2p.html#gnn-implementation",
    "title": "P2G & G2P Transfers",
    "section": "GNN Implementation",
    "text": "GNN Implementation\nIn this codebase, P2G is implemented using a Graph Neural Network for flexibility:\n\nGraph Structure\nNodes: V = V_particles ∪ V_grid\nEdges: E = {(i, j) : j ∈ 3×3 neighborhood of particle i}\n\n\nNode Features\n\n\n\nNode Type\nFeatures\n\n\n\n\nParticle\n\\((m_i, v_{i,x}, v_{i,y})\\)\n\n\nGrid\n\\((0, 0, 0)\\) initially\n\n\n\n\n\nEdge Features\n\n\n\nFeature\nDescription\n\n\n\n\nweights_per_edge\nB-spline weight \\(w_{ij}\\)\n\n\naffine_per_edge\nAffine matrix \\(\\mathbf{Q}_i\\)\n\n\ndpos_per_edge\nOffset \\((\\mathbf{x}_j - \\mathbf{x}_i)\\)\n\n\n\n\n\nMessage Passing\nThe GNN aggregates particle contributions:\n\\[\n\\mathbf{m}_{\\mathbf{j}} = \\sum_{i : (i,\\mathbf{j}) \\in E} w_{i\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nThis sum aggregation produces grid mass and momentum."
  },
  {
    "objectID": "p2g-g2p.html#implementation-in-code",
    "href": "p2g-g2p.html#implementation-in-code",
    "title": "P2G & G2P Transfers",
    "section": "Implementation in Code",
    "text": "Implementation in Code\n\nP2G (from MPM_step.py)\n# Compute base index and fractional position\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n\nG2P (from MPM_step.py)\n# Accumulate velocity from grid neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\nouter_products = torch.bmm(g_v_flat, dpos_flat)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)"
  }
]