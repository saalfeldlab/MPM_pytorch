[
  {
    "objectID": "p2g-g2p.html",
    "href": "p2g-g2p.html",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#overview",
    "href": "p2g-g2p.html#overview",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "href": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "title": "P2G & G2P Transfers",
    "section": "Quadratic B-Spline Interpolation",
    "text": "Quadratic B-Spline Interpolation\nEach particle interacts with a 3×3 stencil of neighboring grid nodes (in 2D).\n\nFinding the Base Node\nFor particle at position \\(\\mathbf{x}_i\\):\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i \\cdot n_{\\text{grid}} - 0.5 \\rfloor\n\\]\n\n\nFractional Position\n\\[\n\\mathbf{f}_x = \\mathbf{x}_i \\cdot n_{\\text{grid}} - \\mathbf{j}_{\\text{base}}\n\\]\nThis gives the particle’s position within its local cell, with \\(\\mathbf{f}_x \\in [0.5, 1.5]\\).\n\n\nWeight Functions\nThe quadratic B-spline weights ensure \\(C^1\\) continuity:\n\n\n\nWeight\nFormula\nRange\n\n\n\n\n\\(w_0\\)\n\\(0.5(1.5 - f_x)^2\\)\nNode at base\n\n\n\\(w_1\\)\n\\(0.75 - (f_x - 1)^2\\)\nNode at base+1\n\n\n\\(w_2\\)\n\\(0.5(f_x - 0.5)^2\\)\nNode at base+2\n\n\n\nFor 2D, the combined weight is:\n\\[\nw_{jk} = w_j(f_{x,1}) \\cdot w_k(f_{x,2})\n\\]\n\n\n\n\n\n\nTipProperties of B-Spline Weights\n\n\n\n\nPartition of unity: \\(\\sum_j w_j = 1\\)\nNon-negative: \\(w_j \\geq 0\\)\nCompact support: Only 9 non-zero weights per particle (2D)"
  },
  {
    "objectID": "p2g-g2p.html#p2g-transfer-details",
    "href": "p2g-g2p.html#p2g-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "P2G Transfer Details",
    "text": "P2G Transfer Details\n\nMass Transfer\nEach particle distributes its mass to neighboring nodes:\n\\[\n\\Delta m_{\\mathbf{j}} = w_{\\mathbf{j}} \\cdot m_i\n\\]\n\n\nMomentum Transfer (APIC)\nThe Affine Particle-In-Cell (APIC) method transfers both linear and angular momentum:\n\\[\n\\Delta \\mathbf{p}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nwhere: - \\(\\mathbf{d}_{i\\mathbf{j}} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\\) is the offset vector - \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum matrix\n\n\nStress Contribution\nThe stress tensor is scaled for P2G:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\nwhere \\(V_p\\) is the particle volume."
  },
  {
    "objectID": "p2g-g2p.html#g2p-transfer-details",
    "href": "p2g-g2p.html#g2p-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "G2P Transfer Details",
    "text": "G2P Transfer Details\n\nVelocity Update\n\\[\n\\mathbf{v}_i^{\\text{new}} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}}^{\\text{grid}}\n\\]\n\n\nAffine Velocity Matrix (APIC)\nThe local velocity gradient is reconstructed:\n\\[\n\\mathbf{C}_i^{\\text{new}} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}} \\otimes \\mathbf{d}_{\\mathbf{j}i}\n\\]\nwhere \\(\\mathbf{d}_{\\mathbf{j}i} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) / \\Delta x\\) is the normalized offset.\n\n\n\n\n\n\nNoteWhy APIC?\n\n\n\nThe Affine Particle-In-Cell method: - Conserves angular momentum exactly - Eliminates numerical damping from traditional PIC/FLIP - Provides smoother, more stable simulations"
  },
  {
    "objectID": "p2g-g2p.html#gnn-implementation",
    "href": "p2g-g2p.html#gnn-implementation",
    "title": "P2G & G2P Transfers",
    "section": "GNN Implementation",
    "text": "GNN Implementation\nIn this codebase, P2G is implemented using a Graph Neural Network for flexibility:\n\nGraph Structure\nNodes: V = V_particles ∪ V_grid\nEdges: E = {(i, j) : j ∈ 3×3 neighborhood of particle i}\n\n\nNode Features\n\n\n\nNode Type\nFeatures\n\n\n\n\nParticle\n\\((m_i, v_{i,x}, v_{i,y})\\)\n\n\nGrid\n\\((0, 0, 0)\\) initially\n\n\n\n\n\nEdge Features\n\n\n\nFeature\nDescription\n\n\n\n\nweights_per_edge\nB-spline weight \\(w_{ij}\\)\n\n\naffine_per_edge\nAffine matrix \\(\\mathbf{Q}_i\\)\n\n\ndpos_per_edge\nOffset \\((\\mathbf{x}_j - \\mathbf{x}_i)\\)\n\n\n\n\n\nMessage Passing\nThe GNN aggregates particle contributions:\n\\[\n\\mathbf{m}_{\\mathbf{j}} = \\sum_{i : (i,\\mathbf{j}) \\in E} w_{i\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nThis sum aggregation produces grid mass and momentum."
  },
  {
    "objectID": "p2g-g2p.html#implementation-in-code",
    "href": "p2g-g2p.html#implementation-in-code",
    "title": "P2G & G2P Transfers",
    "section": "Implementation in Code",
    "text": "Implementation in Code\n\nP2G (from MPM_step.py)\n# Compute base index and fractional position\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n\nG2P (from MPM_step.py)\n# Accumulate velocity from grid neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\nouter_products = torch.bmm(g_v_flat, dpos_flat)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)"
  },
  {
    "objectID": "materials.html",
    "href": "materials.html",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#overview",
    "href": "materials.html#overview",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#material-masks",
    "href": "materials.html#material-masks",
    "title": "Material Types",
    "section": "Material Masks",
    "text": "Material Masks\nIn the code, materials are distinguished by type ID:\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)"
  },
  {
    "objectID": "materials.html#liquid-t-0",
    "href": "materials.html#liquid-t-0",
    "title": "Material Types",
    "section": "Liquid (\\(T = 0\\))",
    "text": "Liquid (\\(T = 0\\))\nLiquids are incompressible fluids with no resistance to shear deformation.\n\nProperties\n\nShear modulus: \\(\\mu = 0\\)\nDeformation: Isotropic only\n\n\n\nDeformation Gradient\nFor liquids, the deformation gradient is reset to preserve only volume:\n\\[\n\\mathbf{F}^{\\text{liquid}} = \\sqrt{J} \\cdot \\mathbf{I}\n\\]\nwhere \\(J = \\det(\\mathbf{F})\\) is the volume ratio.\n\n\n\n\n\n\nNotePhysical Interpretation\n\n\n\nThis ensures liquids have no “shape memory”—they flow to fill any container while preserving volume (incompressibility).\n\n\n\n\nSurface Tension (Optional)\nWhen enabled, surface tension creates cohesive forces between liquid particles:\n\\[\n\\boldsymbol{\\sigma}_{\\text{surface}} = -\\gamma \\cdot s \\cdot (\\mathbf{n} \\otimes \\mathbf{n})\n\\]\nwhere: - \\(\\gamma\\) is the surface tension coefficient - \\(s\\) measures how much of a “surface particle” each particle is - \\(\\mathbf{n}\\) is the direction toward the local center of mass"
  },
  {
    "objectID": "materials.html#jelly-t-1",
    "href": "materials.html#jelly-t-1",
    "title": "Material Types",
    "section": "Jelly (\\(T = 1\\))",
    "text": "Jelly (\\(T = 1\\))\nJelly represents elastic solids that deform and return to their original shape.\n\nProperties\n\nHardening factor: Fixed at \\(h = 0.3\\) (70% softer than reference)\nFull elastic response: Both shear and bulk resistance\n\n\n\nStress Response\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nThe rotation \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is extracted from SVD of \\(\\mathbf{F}\\).\n\n\n\n\n\n\nTipJelly Behavior\n\n\n\n\nBounces back after deformation\nPreserves shape memory\nNo permanent (plastic) deformation"
  },
  {
    "objectID": "materials.html#snow-t-2",
    "href": "materials.html#snow-t-2",
    "title": "Material Types",
    "section": "Snow (\\(T = 2\\))",
    "text": "Snow (\\(T = 2\\))\nSnow exhibits elastoplastic behavior with hardening and softening.\n\nPlasticity Model\nThe singular values of \\(\\mathbf{F}\\) are clamped to limit elastic deformation:\n\\[\n\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, 1 - 2.5 \\times 10^{-2}, 1 + 4.5 \\times 10^{-3})\n\\]\n\n\n\nLimit\nValue\nMeaning\n\n\n\n\nLower\n0.975\nMax 2.5% compression before plastic flow\n\n\nUpper\n1.0045\nMax 0.45% stretch before plastic flow\n\n\n\n\n\nPlastic Volume Accumulation\n\\[\nJ_p^{\\text{new}} = J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\n\\]\nThis tracks cumulative plastic deformation.\n\n\nHardening\nThe hardening factor depends on plastic history:\n\\[\nh = \\exp(10 \\cdot (1 - J_p))\n\\]\n\n\n\n\\(J_p\\)\n\\(h\\)\nMaterial State\n\n\n\n\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nCompressed, harder\n\n\n\\(= 1\\)\n\\(= 1\\)\nReference state\n\n\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nExpanded, softer\n\n\n\n\n\nReconstructed Deformation\nAfter plasticity projection:\n\\[\n\\mathbf{F}^{\\text{snow}} = \\mathbf{U} \\cdot \\text{diag}(\\sigma_k^{\\text{new}}) \\cdot \\mathbf{V}^T\n\\]"
  },
  {
    "objectID": "materials.html#material-parameters",
    "href": "materials.html#material-parameters",
    "title": "Material Types",
    "section": "Material Parameters",
    "text": "Material Parameters\n\nLame Parameters\nFrom Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\):\n\\[\n\\mu_0 = \\frac{E}{2(1+\\nu)}, \\quad \\lambda_0 = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n\\]\n\n\nDefault Values\n\n\n\nParameter\nSymbol\nValue\n\n\n\n\nYoung’s modulus\n\\(E\\)\n\\(10^3\\) Pa\n\n\nPoisson’s ratio\n\\(\\nu\\)\n0.2\n\n\nShear modulus\n\\(\\mu_0\\)\n417 Pa\n\n\nLame first\n\\(\\lambda_0\\)\n278 Pa\n\n\n\n\n\nMaterial-Specific Adjustments\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\n\n# Jelly: fixed softness\nh = torch.where(jelly_mask, 0.3, h)\n\n# Apply to Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\n\n# Liquids: no shear\nmu = torch.where(liquid_mask, 0.0, mu)"
  },
  {
    "objectID": "materials.html#density-and-mass",
    "href": "materials.html#density-and-mass",
    "title": "Material Types",
    "section": "Density and Mass",
    "text": "Density and Mass\nDifferent materials can have different densities:\n# Config example\nsimulation:\n  MPM_rho_list: [1000, 1200, 400]  # [liquid, jelly, snow] kg/m³\nParticle mass is computed as:\n\\[\nm_i = \\rho_{T_i} \\cdot V_p\n\\]\nwhere \\(V_p = (\\Delta x / 2)^2\\) is the particle volume."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MPM PyTorch",
    "section": "",
    "text": "MPM-Pytorch is a differentiable implementation based on taichi_mpm by Yuanming Hu. It provides a fully differentiable MPM solver, enabling:\nThe Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "MPM PyTorch",
    "section": "",
    "text": "MPM-Pytorch is a differentiable implementation based on taichi_mpm by Yuanming Hu. It provides a fully differentiable MPM solver, enabling:\nThe Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches."
  },
  {
    "objectID": "index.html#hybrid-lagrangian-eulerian-approach",
    "href": "index.html#hybrid-lagrangian-eulerian-approach",
    "title": "MPM PyTorch",
    "section": "Hybrid Lagrangian-Eulerian Approach",
    "text": "Hybrid Lagrangian-Eulerian Approach\nMPM uses a hybrid approach where:\n\nParticles carry material state (mass, velocity, deformation history)\nGrid handles momentum transfer and boundary conditions\n\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\nDeformation gradient update: \\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nCauchy stress from constitutive model\n\n\n3\nP2G Transfer\nScatter mass & momentum to grid\n\n\n4\nGrid Operations\nApply gravity, boundary conditions\n\n\n5\nG2P Transfer\nGather velocities back to particles\n\n\n6\nAdvect\nUpdate particle positions: \\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)\n\n\n\nThe cycle repeats for each timestep."
  },
  {
    "objectID": "index.html#particle-state-variables",
    "href": "index.html#particle-state-variables",
    "title": "MPM PyTorch",
    "section": "Particle State Variables",
    "text": "Particle State Variables\nEach particle \\(i\\) carries the following quantities:\n\n\n\n\n\n\n\n\n\nSymbol\nVariable\nDimension\nDescription\n\n\n\n\n\\(\\mathbf{x}_i\\)\nPosition\n\\(d\\)\nSpatial location (2D or 3D)\n\n\n\\(\\mathbf{v}_i\\)\nVelocity\n\\(d\\)\nMaterial velocity\n\n\n\\(\\mathbf{C}_i\\)\nAffine velocity\n\\(d \\times d\\)\nLocal velocity gradient (APIC)\n\n\n\\(\\mathbf{F}_i\\)\nDeformation gradient\n\\(d \\times d\\)\nTracks total deformation\n\n\n\\(J_i\\)\nPlastic deformation\n\\(1\\)\nAccumulated plastic volume change\n\n\n\\(m_i\\)\nMass\n\\(1\\)\nParticle mass\n\n\n\\(T_i\\)\nMaterial type\n\\(1\\)\n0=liquid, 1=jelly, 2=snow"
  },
  {
    "objectID": "index.html#material-types",
    "href": "index.html#material-types",
    "title": "MPM PyTorch",
    "section": "Material Types",
    "text": "Material Types\nMPM PyTorch supports three material types with distinct behaviors:\n\nLiquidJelly (Elastic Solid)Snow\n\n\n\nNo shear resistance (\\(\\mu = 0\\))\nIsotropic deformation: \\(\\mathbf{F} = \\sqrt{J} \\, \\mathbf{I}\\)\nOptional surface tension\n\n\n\n\nFixed stiffness (\\(h = 0.3\\))\nFull elastic response\nPreserves shape memory\n\n\n\n\nPlastic deformation with clamped singular values\nHardening/softening based on \\(J_p\\)\nCaptures compression and fracture"
  },
  {
    "objectID": "index.html#key-equations",
    "href": "index.html#key-equations",
    "title": "MPM PyTorch",
    "section": "Key Equations",
    "text": "Key Equations\n\nDeformation Gradient Update\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\n\n\nCauchy Stress (Neo-Hookean)\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation from SVD of \\(\\mathbf{F}\\).\n\n\nParticle Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "index.html#d-simulation-gallery",
    "href": "index.html#d-simulation-gallery",
    "title": "MPM PyTorch",
    "section": "2D Simulation Gallery",
    "text": "2D Simulation Gallery\n\nMulti-Material (3 types)CollisionPincerCells\n\n\n9 discs of different materials (liquid, jelly, snow) falling under gravity.\n\n\n\nTwo discs of different materials colliding.\n\n\n\nLiquid and jelly discs squeezing a center jelly disc.\n\n\n\nSoft cell-like bodies with expansion, simulating biological tissue."
  },
  {
    "objectID": "index.html#d-simulation-gallery-1",
    "href": "index.html#d-simulation-gallery-1",
    "title": "MPM PyTorch",
    "section": "3D Simulation Gallery",
    "text": "3D Simulation Gallery\n\nFalling Cubes\n\n\n27 cubes of particles falling in a 3D box (35,937 particles on 128x128x128 grid)."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "MPM PyTorch",
    "section": "Documentation",
    "text": "Documentation\n\n\n\nPage\nContent\n\n\n\n\nMPM Algorithm\nComplete algorithm overview\n\n\nP2G & G2P Transfers\nParticle-grid interpolation\n\n\nMaterial Types\nLiquid, jelly, snow behaviors\n\n\nConstitutive Models\nStress computation\n\n\nImplementation\nCode walkthrough"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "MPM PyTorch",
    "section": "References",
    "text": "References\n\nStomakhin et al. (2013). “A material point method for snow simulation”\nHu et al. (2018). “A moving least squares material point method with displacement discontinuity and two-way rigid body coupling”\nJiang et al. (2015). “The affine particle-in-cell method”"
  },
  {
    "objectID": "constitutive.html",
    "href": "constitutive.html",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#overview",
    "href": "constitutive.html#overview",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#deformation-gradient",
    "href": "constitutive.html#deformation-gradient",
    "title": "Constitutive Models",
    "section": "Deformation Gradient",
    "text": "Deformation Gradient\nThe deformation gradient \\(\\mathbf{F}\\) is a \\(d \\times d\\) matrix (2×2 in 2D) that maps from reference to deformed configuration:\n\\[\nd\\mathbf{x} = \\mathbf{F} \\cdot d\\mathbf{X}\n\\]\n\nUpdate Rule\n\\[\n\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\, \\mathbf{F}^n\n\\]\nwhere \\(\\mathbf{C}\\) is the affine velocity matrix (velocity gradient).\n\n\nSVD Decomposition\nFor stress computation and plasticity:\n\\[\n\\mathbf{F} = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\n\n\n\nComponent\nSize\nInterpretation\n\n\n\n\n\\(\\mathbf{U}\\)\n\\(d \\times d\\)\nLeft rotation\n\n\n\\(\\boldsymbol{\\Sigma}\\)\n\\(d \\times d\\)\nStretch (diagonal)\n\n\n\\(\\mathbf{V}^T\\)\n\\(d \\times d\\)\nRight rotation\n\n\n\n\n\nKey Quantities\n\n\n\nSymbol\nFormula\nMeaning\n\n\n\n\n\\(J\\)\n\\(\\det(\\mathbf{F}) = \\prod_k \\sigma_k\\)\nVolume ratio\n\n\n\\(\\mathbf{R}\\)\n\\(\\mathbf{U}\\mathbf{V}^T\\)\nRotation component"
  },
  {
    "objectID": "constitutive.html#fixed-corotated-model",
    "href": "constitutive.html#fixed-corotated-model",
    "title": "Constitutive Models",
    "section": "Fixed Corotated Model",
    "text": "Fixed Corotated Model\nThe stress depends on how much \\(\\mathbf{F}\\) deviates from a pure rotation.\n\nFirst Piola-Kirchhoff Stress\n\\[\n\\mathbf{P} = 2\\mu (\\mathbf{F} - \\mathbf{R}) + \\lambda (J - 1) J \\mathbf{F}^{-T}\n\\]\n\n\nCauchy Stress (Used in Code)\n\\[\n\\boldsymbol{\\sigma} = \\frac{1}{J} \\mathbf{P} \\mathbf{F}^T = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\n\n\nComponents\n\n\n\n\n\n\n\nTerm\nPhysical Meaning\n\n\n\n\n\\(2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T\\)\nShear resistance (shape recovery)\n\n\n\\(\\lambda J (J-1) \\mathbf{I}\\)\nBulk resistance (volume recovery)\n\n\n\n\n\n\n\n\n\nNoteWhy “Corotated”?\n\n\n\nThe model measures deformation relative to the rotation \\(\\mathbf{R}\\), making it frame-invariant and stable under large rotations."
  },
  {
    "objectID": "constitutive.html#hardening-model",
    "href": "constitutive.html#hardening-model",
    "title": "Constitutive Models",
    "section": "Hardening Model",
    "text": "Hardening Model\nMaterial stiffness varies with plastic history through the hardening factor \\(h\\):\n\\[\nh = \\exp(10 (1 - J_p))\n\\]\n\nEffect on Lame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\nPhysical Interpretation\n\n\n\nState\n\\(J_p\\)\n\\(h\\)\nMaterial\n\n\n\n\nCompressed\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nStiffer\n\n\nReference\n\\(= 1\\)\n\\(= 1\\)\nNormal\n\n\nExpanded\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nSofter"
  },
  {
    "objectID": "constitutive.html#plasticity-snow-only",
    "href": "constitutive.html#plasticity-snow-only",
    "title": "Constitutive Models",
    "section": "Plasticity (Snow Only)",
    "text": "Plasticity (Snow Only)\nSnow undergoes irreversible plastic deformation when stretched or compressed beyond limits.\n\nYield Surface\nThe singular values are constrained:\n\\[\n\\sigma_k \\in [1 - \\epsilon_c, 1 + \\epsilon_s]\n\\]\n\n\n\nParameter\nValue\nMeaning\n\n\n\n\n\\(\\epsilon_c\\)\n0.025\nCompression limit\n\n\n\\(\\epsilon_s\\)\n0.0045\nStretch limit\n\n\n\n\n\nPlastic Flow\nWhen singular values exceed limits:\n\nClamp to valid range: \\(\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, ...)\\)\nUpdate plastic deformation: \\(J_p \\leftarrow J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\\)\nReconstruct: \\(\\mathbf{F} \\leftarrow \\mathbf{U} \\, \\text{diag}(\\sigma_k^{\\text{new}}) \\, \\mathbf{V}^T\\)"
  },
  {
    "objectID": "constitutive.html#stress-scaling-for-mpm",
    "href": "constitutive.html#stress-scaling-for-mpm",
    "title": "Constitutive Models",
    "section": "Stress Scaling for MPM",
    "text": "Stress Scaling for MPM\nThe stress is scaled for P2G momentum transfer:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\n\nAffine Momentum\nThe final quantity transferred to grid:\n\\[\n\\mathbf{Q} = \\text{stress} + m \\, \\mathbf{C}\n\\]"
  },
  {
    "objectID": "constitutive.html#implementation",
    "href": "constitutive.html#implementation",
    "title": "Constitutive Models",
    "section": "Implementation",
    "text": "Implementation\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F_reg)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)))\n\n# Scale for P2G\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass * C"
  },
  {
    "objectID": "constitutive.html#energy-density",
    "href": "constitutive.html#energy-density",
    "title": "Constitutive Models",
    "section": "Energy Density",
    "text": "Energy Density\nThe stored elastic energy (for reference):\n\\[\n\\Psi = \\mu \\|\\mathbf{F} - \\mathbf{R}\\|_F^2 + \\frac{\\lambda}{2}(J-1)^2\n\\]\nThis energy is minimized when: - \\(\\mathbf{F} = \\mathbf{R}\\) (pure rotation, no stretch) - \\(J = 1\\) (no volume change)"
  },
  {
    "objectID": "implementation.html",
    "href": "implementation.html",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#code-structure",
    "href": "implementation.html#code-structure",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#key-files",
    "href": "implementation.html#key-files",
    "title": "Implementation",
    "section": "Key Files",
    "text": "Key Files\n\nMPM_step.py - Core Algorithm\nThe heart of the simulation. Contains:\n\nMPM_step(): Complete time step\ncompute_surface_tension_stress(): Liquid surface tension\n\n\n\ngraph_data_generator.py - Simulation Runner\nOrchestrates the full simulation:\n\ndata_generate_MPM_2D(): 2D simulation loop\nInitialization of particle states\nFrame-by-frame stepping\nVisualization output"
  },
  {
    "objectID": "implementation.html#mpm-step-implementation",
    "href": "implementation.html#mpm-step-implementation",
    "title": "Implementation",
    "section": "MPM Step Implementation",
    "text": "MPM Step Implementation\n\nFunction Signature\ndef MPM_step(\n    model_MPM,      # GNN model for P2G\n    X, V, C, F, Jp, T, M,  # Particle states\n    n_particles, n_grid,   # Dimensions\n    dt, dx, inv_dx,        # Time/space steps\n    mu_0, lambda_0,        # Material parameters\n    p_vol, offsets, particle_offsets,\n    expansion_factor, gravity, friction,\n    frame,\n    surface_tension_coeff, tension_scaling,\n    enable_surface_tension, debug_surface,\n    device\n):\n\n\nPhase 1: Deformation Update\n# Material masks\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)\n\n# Update deformation gradient\nidentity = torch.eye(2, device=device).unsqueeze(0)\nF = (identity + dt * C) @ F\n\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\nh = torch.where(jelly_mask, 0.3, h)  # Fixed for jelly\n\n# Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\nmu = torch.where(liquid_mask, 0.0, mu)  # No shear for liquid\n\n\nPhase 2: SVD and Plasticity\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F + 1e-6 * identity)\n\n# Sign corrections for proper rotations\ndet_U = torch.det(U)\nneg_det_U = det_U &lt; 0\nif neg_det_U.any():\n    U[neg_det_U, :, -1] *= -1\n    sig[neg_det_U, -1] *= -1\n\n# Snow plasticity: clamp singular values\nsig = torch.where(\n    snow_mask.unsqueeze(1),\n    torch.clamp(sig, min=1-2.5e-2, max=1+4.5e-3),\n    sig\n)\n\n# Update plastic deformation\nJp = Jp * torch.prod(original_sig / sig, dim=1, keepdim=True)\n\n\nPhase 3: Stress Computation\n# Volume ratio\nJ = torch.prod(sig, dim=1)\nJ = torch.clamp(J, min=1e-4)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu.unsqueeze(-1).unsqueeze(-1) * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)).unsqueeze(-1).unsqueeze(-1))\n\n# Scale for P2G transfer\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C\n\n\nPhase 4: P2G Transfer\n# Base grid node\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n# Build graph for GNN\ndataset = data.Data(\n    x=x_,\n    edge_index=edge_index,\n    weights_per_edge=weights_per_edge,\n    affine_per_edge=affine_per_edge,\n    dpos_per_edge=dpos_per_edge\n)\n\n# GNN forward pass\ngrid_output = model_MPM(dataset)[0:n_grid**2]\ngrid_m = grid_output[:, 0].view(n_grid, n_grid)\ngrid_v = grid_output[:, 1:3].view(n_grid, n_grid, 2)\n\n\nPhase 5: Grid Operations\n# Momentum to velocity\nvalid_mass_mask = grid_m &gt; 0\ngrid_v = torch.where(\n    valid_mass_mask.unsqueeze(-1),\n    grid_v / (grid_m.unsqueeze(-1) + 1e-10),\n    grid_v\n)\n\n# Apply gravity\ngravity_force = torch.tensor([0.0, dt * gravity], device=device)\ngrid_v = grid_v + gravity_force\n\n# Boundary conditions\ngrid_v[:, :, 0] = torch.where(left_mask & (grid_v[:, :, 0] &lt; 0), 0.0, grid_v[:, :, 0])\ngrid_v[:, :, 0] = torch.where(right_mask & (grid_v[:, :, 0] &gt; 0), 0.0, grid_v[:, :, 0])\n# ... similar for y-component\n\n\nPhase 6: G2P Transfer\n# Gather velocities from 9 neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\ng_v_flat = g_v_all.reshape(-1, 2, 1)\ndpos_flat = dpos_all.reshape(-1, 1, 2)\nouter_products = torch.bmm(g_v_flat, dpos_flat).reshape(n_particles, 9, 2, 2)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)\n\n# Advection\nX = X + dt * new_V"
  },
  {
    "objectID": "implementation.html#data-generation",
    "href": "implementation.html#data-generation",
    "title": "Implementation",
    "section": "Data Generation",
    "text": "Data Generation\n\nInitialization (graph_data_generator.py)\ndef data_generate_MPM_2D(config, ...):\n    # Grid parameters\n    n_grid = simulation_config.n_grid\n    dx, inv_dx = 1 / n_grid, float(n_grid)\n\n    # Material parameters\n    E, nu = 0.1e4 / young_coeff, 0.2\n    mu_0 = E / (2 * (1 + nu))\n    lambda_0 = E * nu / ((1 + nu) * (1 - 2 * nu))\n\n    # Initialize particles\n    N, X, V, C, F, T, Jp, M, S, ID = init_MPM_shapes(...)\n\n    # Simulation loop\n    for frame in range(n_frames):\n        X, V, C, F, Jp, T, M, stress, grid_m, grid_v = MPM_step(\n            model_MPM, X, V, C, F, Jp, T, M,\n            n_particles, n_grid, dt, dx, inv_dx,\n            mu_0, lambda_0, p_vol, offsets, particle_offsets,\n            expansion_factor, gravity, friction, frame,\n            surface_tension_coeff, tension_scaling,\n            enable_surface_tension, debug_surface,\n            device\n        )\n\n        # Save frame data\n        x_list.append(...)"
  },
  {
    "objectID": "implementation.html#configuration",
    "href": "implementation.html#configuration",
    "title": "Implementation",
    "section": "Configuration",
    "text": "Configuration\nExample YAML config:\ndescription: \"Multi-material simulation with 3 types\"\ndataset: \"multimaterial/multimaterial_1_discs_3types\"\n\nsimulation:\n  n_particles: 9600\n  n_particle_types: 3\n  n_grid: 128\n  n_frames: 2000\n  delta_t: 1.0E-4\n\n  # Material parameters\n  MPM_n_objects: 3\n  MPM_object_type: [0, 1, 2]  # liquid, jelly, snow\n  MPM_rho_list: [1000, 1200, 400]\n  MPM_young_coeff: 1.0\n  MPM_gravity: -200\n  MPM_friction: 0.5\n  MPM_expansion_factor: 1.0\n  MPM_surface_tension: 0.0\n\ntraining:\n  n_runs: 1\n  device: auto"
  },
  {
    "objectID": "implementation.html#running-simulations",
    "href": "implementation.html#running-simulations",
    "title": "Implementation",
    "section": "Running Simulations",
    "text": "Running Simulations\n# Generate data\npython run_MPM.py -o generate multimaterial_1_discs_3types\n\n# Train INR model\npython run_MPM.py -o train_INR multimaterial_1_discs_3types\n\n# Claude-guided exploration\npython run_MPM.py -o train_INR_Claude multimaterial_1_discs_3types iterations=100"
  },
  {
    "objectID": "llm-exploration.html",
    "href": "llm-exploration.html",
    "title": "LLM-Guided INR Optimization",
    "section": "",
    "text": "This page documents an ongoing LLM-in-the-loop exploration to optimize SIREN (Sinusoidal Representation Network) parameters for representing MPM particle fields over time. The exploration uses UCB tree search to systematically tune hyperparameters for each field type.\n\n\n\n\n\n\nNoteGoal\n\n\n\nFind optimal SIREN configurations to accurately represent time-varying particle fields (\\(J_p\\), \\(\\mathbf{F}\\), \\(\\mathbf{C}\\), \\(\\mathbf{S}\\)) for 9000 particles over 100–200 frames."
  },
  {
    "objectID": "llm-exploration.html#overview",
    "href": "llm-exploration.html#overview",
    "title": "LLM-Guided INR Optimization",
    "section": "",
    "text": "This page documents an ongoing LLM-in-the-loop exploration to optimize SIREN (Sinusoidal Representation Network) parameters for representing MPM particle fields over time. The exploration uses UCB tree search to systematically tune hyperparameters for each field type.\n\n\n\n\n\n\nNoteGoal\n\n\n\nFind optimal SIREN configurations to accurately represent time-varying particle fields (\\(J_p\\), \\(\\mathbf{F}\\), \\(\\mathbf{C}\\), \\(\\mathbf{S}\\)) for 9000 particles over 100–200 frames."
  },
  {
    "objectID": "llm-exploration.html#siren-architecture",
    "href": "llm-exploration.html#siren-architecture",
    "title": "LLM-Guided INR Optimization",
    "section": "SIREN Architecture",
    "text": "SIREN Architecture\nSIREN (Sinusoidal Representation Network) uses sine activations instead of ReLU, enabling smooth derivatives for representing continuous fields:\n\\[\\phi(x) = \\sin(\\omega_0 \\cdot Wx + b)\\]\n\nInput-Output Mapping\nThe INR maps normalized time and particle positions to field values:\n\\[\n\\text{SIREN}: (t/T, \\, x, \\, y) \\rightarrow \\text{field}(t, x, y)\n\\]\nwhere \\(T\\) = number of frames. Time is normalized to [0, 1], and positions \\((x, y)\\) are scaled by nnr_f_xy_period.\nThree input variants are supported:\n\n\n\n\n\n\n\n\n\nVariant\nInput\nOutput\nUse Case\n\n\n\n\nsiren_id\n\\((t, \\text{id})\\)\nField value for one particle\nIndex-based encoding\n\n\nsiren_t\n\\(t\\) only\nAll particles at once\nFaster but less flexible\n\n\nsiren_txy\n\\((t, x, y)\\)\nField value at position\n✅ Used for all results below\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll results on this page use inr_type: siren_txy — the network learns a mapping from (time, x, y) to field values, using Lagrangian particle positions for position-aware encoding.\n\n\n\n\nFrequency Parameter (omega_f)\nThe omega_f parameter controls the network’s frequency capacity — higher values capture finer spatial/temporal detail but risk training instability:\n\n\n\nomega_f\nBehavior\nRecommended For\n\n\n\n\n1–10\nSmooth, low-frequency\nSimple fields (Jp)\n\n\n10–30\nMedium detail\nMost fields (F, C)\n\n\n30–100\nHigh-frequency detail\nComplex fields (S), unstable\n\n\n\nKey finding: omega_f is field-specific and frame-dependent. More particles → lower optimal omega_f.\n\n\nPeriod Parameters (for siren_txy)\nWhen using position-based input (t, x, y), two scaling parameters control how the network interprets coordinates:\n\n\n\n\n\n\n\n\nParameter\nFormula\nEffect\n\n\n\n\nnnr_f_T_period\n\\(t_{\\text{norm}} = t / T / \\text{period}\\)\nHigher → expects slower temporal variation\n\n\nnnr_f_xy_period\n\\((x,y)_{\\text{norm}} = (x,y) / \\text{period}\\)\nHigher → expects slower spatial variation\n\n\n\nIntuition: Period=10 means the network treats the full range as 1/10th of its natural period.\n\n\nTunable Parameters\n\n\n\nParameter\nDescription\nSearch Range\n\n\n\n\nn_training_frames\nFrames encoded in SIREN\n100\n\n\nhidden_dim\nWidth of hidden layers\n256–1280\n\n\nn_layers\nNumber of hidden layers\n2–5\n\n\nomega_f\nSIREN frequency multiplier\n5–50\n\n\nlr_NNR_f\nLearning rate\n1E-5–1E-4\n\n\ntotal_steps\nTraining iterations\n100k–200k"
  },
  {
    "objectID": "llm-exploration.html#field-specific-results",
    "href": "llm-exploration.html#field-specific-results",
    "title": "LLM-Guided INR Optimization",
    "section": "Field-Specific Results",
    "text": "Field-Specific Results\n\n\\(J_p\\) — Plastic Deformation (Block 1)\nn_training_frames: 100 | n_particles: 9000\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.996 with 512×3 @ omega=5-10, lr=4E-5, 200k steps (15.4 min)\nSpeed Pareto: 384×3 @ omega=10 achieves R²=0.995 in 12.2 min\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n5–10 (LOWER than prior=15)\n\n\nOptimal depth\n3 layers (ceiling)\n\n\nOptimal lr\n4E-5\n\n\n\n\nVideoFinal Field\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{F}\\) — Deformation Gradient (Block 2)\nn_training_frames: 100 | n_particles: 9000\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.998 with 256×4 @ omega=12, lr=4E-5 to 6E-5, 150k steps (8.1 min)\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n12 (SHARP optimum, ±1 degrades)\n\n\nOptimal depth\n4 layers (different from Jp)\n\n\nOptimal lr\nWide tolerance [4E-5, 6E-5]\n\n\nCapacity ceiling\n256 (384 hurts performance)\n\n\n\n\nVideoFinal Field\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{C}\\) — Affine Velocity (Block 3)\nn_training_frames: 100 | n_particles: 9000\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.994 with 640×3 @ omega=25, lr=2E-5, 150k steps (15.7 min)\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n25 (unchanged from prior, NO lower shift)\n\n\nOptimal depth\n3 layers (same as Jp)\n\n\nOptimal lr\n2E-5 (LOWER than Jp/F)\n\n\nCapacity ceiling\n640 (between F@256 and S@1280)\n\n\n\n\nVideoFinal Field\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{S}\\) — Stress (Block 4)\nn_training_frames: 100 | n_particles: 9000\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.729 with 1280×3 @ omega=48, lr=2E-5, 300k steps (166.2 min)\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n48 (no lower shift, similar to prior 50)\n\n\nOptimal depth\n3 layers (NOT 4 like prior)\n\n\nCapacity requirement\n1280 (confirmed, 640 fails)\n\n\nOptimal lr\n2E-5 (hard-locked, 3E-5 catastrophic)\n\n\nR² ceiling\n0.729 — hardest field on this dataset\n\n\n\n\nVideoFinal Field\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{F}\\) — Deformation Gradient at 200 frames (Block 5)\nn_training_frames: 200 | n_particles: 9000\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.9997 with 256×4 @ omega=9, lr=5E-5, 300k steps (32.4 min)\nSpeed Pareto: 200k steps achieves R²=0.9988 in 27.6 min\n\n\n\n\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n9–10 (shifted from 12 at 100f — more frames → lower omega)\n\n\nOptimal depth\n4 layers (same as F@100f)\n\n\nOptimal lr\n5E-5 (narrower than 100f tolerance)\n\n\nCapacity ceiling\n256 (re-confirmed, 384 overparameterized)\n\n\nPeriod params\nT_period=1.0 and xy_period=1.0 MANDATORY\n\n\n\n\n\n\n\n\n\nWarningPeriod Sensitivity\n\n\n\nT_period=2.0 causes catastrophic degradation (R²=0.790). xy_period=2.0 causes significant degradation (R²=0.987). Temporal smoothing 6× more damaging than spatial.\n\n\n\nVideoFinal Field\n\n\n\n\n\n\n\n\n\n\n\n\n\\(J_p\\) — Plastic Deformation at 200 frames (Block 6, In Progress)\nn_training_frames: 200 | n_particles: 9000\n\n\n\n\n\n\nWarningCurrently Exploring\n\n\n\nBest so far: R² = 0.995 with 512×3 @ omega=5, lr=4E-5, 400k steps (67.8 min)\nKey findings (iterations 61-67):\n\nJp@200f maintains R²=0.995 (vs 0.996 at 100f) — quality preserved\nomega_f extremely flat [3–7]: all yield R²=0.992–0.995. omega_f=5 wins on slope\nStep count is dominant: 400k steps (R²=0.995) vs 300k (R²=0.992)\nSpeed Pareto: 300k steps achieves R²=0.992 in ~46 min\n\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n3–7 (extremely flat, 5 best on slope)\n\n\nOptimal depth\n3 layers (same as Jp@100f)\n\n\nOptimal lr\n4E-5 at 400k steps, 5E-5 at 300k steps\n\n\nSteps/frame\n2000 needed for R²&gt;0.99\n\n\n\n\nVideoFinal Field"
  },
  {
    "objectID": "llm-exploration.html#key-discoveries",
    "href": "llm-exploration.html#key-discoveries",
    "title": "LLM-Guided INR Optimization",
    "section": "Key Discoveries",
    "text": "Key Discoveries\n\n\n\n\n\nflowchart TD\n    A[Field Type] --&gt; B[Jp]\n    A --&gt; C[F]\n    A --&gt; D[C]\n    A --&gt; E[S]\n\n    B --&gt; B1[\"omega=5-10 (100f) | 3-7 (200f)\"]\n    B --&gt; B2[512×3]\n    B --&gt; B3[\"R²=0.996 (100f) | 0.995 (200f)\"]\n\n    C --&gt; C1[\"omega=12 (100f) | 9 (200f)\"]\n    C --&gt; C2[256×4]\n    C --&gt; C3[\"R²=0.998 (100f) | 0.9997 (200f)\"]\n\n    D --&gt; D1[omega=25]\n    D --&gt; D2[640×3]\n    D --&gt; D3[R²=0.994]\n\n    E --&gt; E1[omega=48]\n    E --&gt; E2[1280×3]\n    E --&gt; E3[R²=0.729]\n\n    style B fill:#c8e6c9\n    style C fill:#c8e6c9\n    style D fill:#c8e6c9\n    style E fill:#fff9c4\n\n\n\n\n\n\n\nEstablished Principles\n\nField-specific architectures required: Jp, F, C, S need DIFFERENT optimal configs on same dataset\nomega_f scales with field complexity: Jp(5-10) &lt; F(12) &lt; C(25) &lt; S(48)\nMore frames → lower omega_f: F shifts 12→9, Jp shifts 7→5 at 200 frames. High-complexity fields (C, S) maintain omega_f\nCapacity requirements vary: F(256) &lt; Jp(512) &lt; C(640) &lt; S(1280)\nLearning rate sensitivity differs: F has wide tolerance at 100f (narrows at 200f), C/S need slower learning (2E-5 hard-locked)\nDepth varies by field: Jp(3), F(4), C(3), S(3) — only F benefits from 4 layers\nPrior configs don’t transfer: S field prior optimal (1280×4, omega=50) failed on new dataset\nData scaling works for F: No diminishing returns from 100→200 frames when omega_f re-tuned (R² 0.998→0.9997)\nPeriod parameters are critical: T_period and xy_period must stay at 1.0 — temporal smoothing 6× more damaging than spatial\nField difficulty ranking: F(0.9997) &gt; Jp(0.996) &gt; C(0.994) &gt;&gt; S(0.729)"
  },
  {
    "objectID": "llm-exploration.html#exploration-progress",
    "href": "llm-exploration.html#exploration-progress",
    "title": "LLM-Guided INR Optimization",
    "section": "Exploration Progress",
    "text": "Exploration Progress\n\n\n\nBlock\nField\nn_training_frames\nIterations\nStatus\nBest R²\n\n\n\n\n1\nJp\n100\n1–12\nComplete\n0.996\n\n\n2\nF\n100\n13–24\nComplete\n0.998\n\n\n3\nC\n100\n25–36\nComplete\n0.994\n\n\n4\nS\n100\n37–48\nComplete\n0.729\n\n\n5\nF\n200\n49–60\nComplete\n0.9997\n\n\n6\nJp\n200\n61–72\nIn progress\n0.995"
  },
  {
    "objectID": "mpm-algorithm.html",
    "href": "mpm-algorithm.html",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#algorithm-overview",
    "href": "mpm-algorithm.html#algorithm-overview",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "href": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "title": "MPM Algorithm",
    "section": "Phase 1: Deformation Gradient Update",
    "text": "Phase 1: Deformation Gradient Update\nThe deformation gradient \\(\\mathbf{F}\\) tracks how material has deformed from its rest configuration.\n\nUpdate Rule\nUsing the Moving Least Squares (MLS) approximation:\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\nwhere \\(\\mathbf{C}_i\\) is the affine velocity matrix capturing local velocity gradients.\n\n\nSVD Decomposition\nFor plasticity and stability, we decompose:\n\\[\n\\mathbf{F}_i = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\nwhere: - \\(\\mathbf{U}, \\mathbf{V}\\) are rotation matrices - \\(\\boldsymbol{\\Sigma} = \\text{diag}(\\sigma_1, \\sigma_2)\\) contains singular values (stretches)\n\n\n\n\n\n\nNoteImplementation Note\n\n\n\nThe code uses torch.linalg.svd with sign corrections to ensure proper rotation matrices (det = +1)."
  },
  {
    "objectID": "mpm-algorithm.html#phase-2-stress-computation",
    "href": "mpm-algorithm.html#phase-2-stress-computation",
    "title": "MPM Algorithm",
    "section": "Phase 2: Stress Computation",
    "text": "Phase 2: Stress Computation\n\nHardening Factor\nMaterial stiffness varies with plastic deformation:\n\\[\nh = \\exp(10(1 - J_p))\n\\]\n\n\\(J_p &lt; 1\\) (compression): \\(h &gt; 1\\) (hardening)\n\\(J_p &gt; 1\\) (expansion): \\(h &lt; 1\\) (softening)\n\n\n\nLame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\n\nParameter\nSymbol\nPhysical Meaning\n\n\n\n\n\\(\\mu\\)\nShear modulus\nResistance to shape change\n\n\n\\(\\lambda\\)\nFirst Lame parameter\nResistance to volume change\n\n\n\n\n\nCauchy Stress\nThe fixed corotated hyperelastic model:\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere: - \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation component - \\(J = \\det(\\mathbf{F}) = \\sigma_1 \\cdot \\sigma_2\\) is the volume ratio"
  },
  {
    "objectID": "mpm-algorithm.html#phase-3-p2g-transfer",
    "href": "mpm-algorithm.html#phase-3-p2g-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 3: P2G Transfer",
    "text": "Phase 3: P2G Transfer\nTransfer particle quantities to the background grid using quadratic B-spline weights.\n\nBase Index\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i / \\Delta x - 0.5 \\rfloor\n\\]\n\n\nB-Spline Weights\nFor fractional position \\(\\mathbf{f}_x = \\mathbf{x}_i / \\Delta x - \\mathbf{j}_{\\text{base}}\\):\n\\[\n\\begin{aligned}\nw_0 &= 0.5(1.5 - f_x)^2 \\\\\nw_1 &= 0.75 - (f_x - 1)^2 \\\\\nw_2 &= 0.5(f_x - 0.5)^2\n\\end{aligned}\n\\]\n\n\nMomentum Transfer\nFor each of the 9 neighboring grid nodes (in 2D):\n\\[\n\\Delta \\mathbf{m}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) \\right)\n\\]\nwhere \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum."
  },
  {
    "objectID": "mpm-algorithm.html#phase-4-grid-operations",
    "href": "mpm-algorithm.html#phase-4-grid-operations",
    "title": "MPM Algorithm",
    "section": "Phase 4: Grid Operations",
    "text": "Phase 4: Grid Operations\n\nMomentum to Velocity\n\\[\n\\mathbf{v}_{\\mathbf{j}} = \\frac{\\mathbf{m}_{\\mathbf{j}}}{m_{\\mathbf{j}}}\n\\]\n\n\nGravity\n\\[\n\\mathbf{v}_{\\mathbf{j}} \\leftarrow \\mathbf{v}_{\\mathbf{j}} + \\Delta t \\, \\mathbf{g}\n\\]\n\n\nBoundary Conditions\n\nNormal: Set penetrating velocity to zero\nTangential: Apply friction: \\(\\mathbf{v}_t \\leftarrow (1-\\alpha) \\mathbf{v}_t\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-5-g2p-transfer",
    "href": "mpm-algorithm.html#phase-5-g2p-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 5: G2P Transfer",
    "text": "Phase 5: G2P Transfer\n\nVelocity Update (APIC)\n\\[\n\\mathbf{v}_i^{n+1} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}}\n\\]\n\n\nAffine Velocity Update\n\\[\n\\mathbf{C}_i^{n+1} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}} \\otimes (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\n\\]\nThe outer product captures local velocity gradients."
  },
  {
    "objectID": "mpm-algorithm.html#phase-6-advection",
    "href": "mpm-algorithm.html#phase-6-advection",
    "title": "MPM Algorithm",
    "section": "Phase 6: Advection",
    "text": "Phase 6: Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "mpm-algorithm.html#complete-variable-flow",
    "href": "mpm-algorithm.html#complete-variable-flow",
    "title": "MPM Algorithm",
    "section": "Complete Variable Flow",
    "text": "Complete Variable Flow\nThis diagram shows how variables in MPM_step.py correspond to the mathematical quantities in MPM.\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         MPM TIME STEP VARIABLE FLOW                         │\n└─────────────────────────────────────────────────────────────────────────────┘\n\nINPUT STATE (per particle)\n┌──────────┬─────────────┬──────────────────────────────────────────────────┐\n│ Variable │ Math Symbol │ Description                                      │\n├──────────┼─────────────┼──────────────────────────────────────────────────┤\n│ X        │ xᵢ          │ Position [n_particles, 2]                        │\n│ V        │ vᵢ          │ Velocity [n_particles, 2]                        │\n│ C        │ Cᵢ          │ Affine velocity matrix [n_particles, 2, 2]       │\n│ F        │ Fᵢ          │ Deformation gradient [n_particles, 2, 2]         │\n│ Jp       │ Jₚ          │ Plastic volume ratio [n_particles, 1]            │\n│ T        │ type        │ Material type (0=liquid, 1=jelly, 2=snow)        │\n│ M        │ mᵢ          │ Mass [n_particles, 1]                            │\n└──────────┴─────────────┴──────────────────────────────────────────────────┘\n\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 1: DEFORMATION GRADIENT UPDATE                                      ║\n║                                                                           ║\n║    F = (I + dt*C) @ F                                                     ║\n║                                                                           ║\n║  Code: F = (identity + dt * C) @ F                            Line 49    ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 1-&gt;2: MATERIAL-SPECIFIC F REFINEMENT                                │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │  SVD DECOMPOSITION                                                  │  │\n│  │                                                                     │  │\n│  │    F = U * Sigma * V^T                                              │  │\n│  │                                                                     │  │\n│  │  Code: U, sig, Vh = torch.linalg.svd(F_reg)            Line 64     │  │\n│  │                                                                     │  │\n│  │  Variables:                                                         │  │\n│  │    U, Vh  -&gt; rotation matrices [n_particles, 2, 2]                  │  │\n│  │    sig    -&gt; singular values (stretches) [n_particles, 2]           │  │\n│  │    J      -&gt; det(F) = sig1*sig2 = torch.prod(sig)                   │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                   │                                      │\n│      ┌─────────────────────────────┼─────────────────────────────┐        │\n│      ▼                             ▼                             ▼        │\n│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐  │\n│  │    LIQUID     │          │     JELLY     │          │     SNOW      │  │\n│  │   (T == 0)    │          │   (T == 1)    │          │   (T == 2)    │  │\n│  ├───────────────┤          ├───────────────┤          ├───────────────┤  │\n│  │ mu = 0        │          │ h = 0.3       │          │ h = exp(10*   │  │\n│  │ (no shear)    │          │ (constant)    │          │    (1-Jp))    │  │\n│  │               │          │               │          │               │  │\n│  │ F = sqrt(J)*I │          │ sig clamped   │          │ sig clamped   │  │\n│  │ (isotropic)   │          │ F = U*Sig*V^T │          │ [0.975,1.0045]│  │\n│  │               │          │               │          │ Jp updated    │  │\n│  └───────────────┘          └───────────────┘          └───────────────┘  │\n│      │                             │                             │        │\n│      └─────────────────────────────┼─────────────────────────────┘        │\n│                                    ▼                                      │\n│  Code references:                                                        │\n│    LIQUID:                                                               │\n│      - mu = 0:   mu = torch.where(liquid_mask, 0.0, mu)      Line 57    │\n│      - F:        F_liquid = identity * sqrt(J)               Line 112   │\n│    JELLY:                                                                │\n│      - h = 0.3:  h = torch.where(jelly_mask, 0.3, h)         Line 52    │\n│      - F:        F_solid = U @ sig_diag @ Vh                 Line 113   │\n│    SNOW:                                                                 │\n│      - h:        h = torch.exp(10 * (1.0 - Jp.squeeze()))    Line 51    │\n│      - clamp:    sig = torch.clamp(sig, 1-2.5e-2, 1+4.5e-3)  Line 98    │\n│      - Jp:       Jp = Jp * plastic_ratio                     Line 102   │\n│      - F:        F_solid = U @ sig_diag @ Vh                 Line 113   │\n│    ALL:                                                                  │\n│      - Lame:     mu = mu_0 * h, la = lambda_0 * h            Lines 55-56│\n└───────────────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 2: STRESS COMPUTATION                                               ║\n║                                                                           ║\n║    R = U * V^T                   (rotation component)                     ║\n║                                                                           ║\n║    stress = 2*mu*(F-R)*F^T + la*J*(J-1)*I   (Cauchy, corotated model)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    R = U @ Vh                                                 Line 123   ║\n║    F_minus_R = F - R                                          Line 124   ║\n║    stress = (2*mu*(F-R)@F^T + la*J*(J-1)*I)                  Line 125-126║\n║    stress = (-dt * p_vol * 4 * inv_dx^2) * stress            Line 127    ║\n║                                                                           ║\n║  The scaling factor converts stress to force for P2G transfer             ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 2-&gt;3: AFFINE MOMENTUM COMPUTATION                                   │\n│                                                                           │\n│  ┌────────────────────────────────────────────────────────────────────┐   │\n│  │                                                                    │   │\n│  │     affine = stress + m * C                                        │   │\n│  │                                                                    │   │\n│  │  Code: affine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C   │   │\n│  │                                                       Line 162    │   │\n│  │                                                                    │   │\n│  │  Physical interpretation:                                          │   │\n│  │    - stress term: internal forces from deformation                 │   │\n│  │    - m*C term: momentum transport (APIC angular momentum)          │   │\n│  │                                                                    │   │\n│  │  This combined \"affine\" carries BOTH force AND momentum info       │   │\n│  │  to the grid in a single transfer.                                 │   │\n│  └────────────────────────────────────────────────────────────────────┘   │\n│                                                                           │\n│  Variables at this point:                                                 │\n│  ┌────────────┬─────────────┬─────────────────────────────────────────┐   │\n│  │ Variable   │ Shape       │ Description                             │   │\n│  ├────────────┼─────────────┼─────────────────────────────────────────┤   │\n│  │ stress     │ [N, 2, 2]   │ Scaled stress (force)                   │   │\n│  │ C          │ [N, 2, 2]   │ Affine velocity matrix                  │   │\n│  │ p_mass     │ [N]         │ Particle mass                           │   │\n│  │ affine     │ [N, 2, 2]   │ Combined force + momentum gradient      │   │\n│  └────────────┴─────────────┴─────────────────────────────────────────┘   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 3: P2G TRANSFER (Particle to Grid)                                  ║\n║                                                                           ║\n║  Each particle i CONTRIBUTES to its 9 neighboring grid nodes j:           ║\n║                                                                           ║\n║    contribution to mass:     dm_j = w_j * m_i                             ║\n║    contribution to momentum: dp_j = w_j * (m_i*v_i + Q_i*(x_j - x_i))     ║\n║                                                                           ║\n║  The GNN ACCUMULATES all particle contributions at each grid node:        ║\n║                                                                           ║\n║    m_j = SUM_i dm_j   (total mass at node j)                              ║\n║    p_j = SUM_i dp_j   (total momentum at node j)                          ║\n║                                                                           ║\n║  Code (MPM_P2G.message computes d, GNN aggregation computes SUM):         ║\n║    out_m = mass_j * weights              # dm_j contribution              ║\n║    out_v = weights * (m*v + Q @ dpos)    # dp_j contribution              ║\n║                                                                           ║\n║  After GNN aggregation (Line 214-216):                                    ║\n║    grid_m = accumulated mass m_j     [n_grid, n_grid]                     ║\n║    grid_v = accumulated momentum p_j [n_grid, n_grid, 2] (NOT velocity!)  ║\n║                                                                           ║\n║  Weights: Quadratic B-spline w0, w1, w2                     Lines 178-181 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 4: GRID OPERATIONS                                                  ║\n║                                                                           ║\n║    v_j = p_j / m_j               (momentum -&gt; velocity, using accumulated)║\n║    v_j += dt * g                 (gravity)                                ║\n║    Apply boundary conditions     (friction, no-penetration)               ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    grid_v = grid_v / (grid_m + eps)                         Line 226-228  ║\n║    grid_v = grid_v + gravity_force                          Line 232-234  ║\n║    Boundary handling                                        Lines 242-266 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 5: G2P TRANSFER                                                     ║\n║                                                                           ║\n║    v_i = SUM_j w_j * v_j              (APIC velocity update)              ║\n║                                                                           ║\n║    C_i = 4/dx^2 * SUM_j w_j * v_j (x) (x_j - x_i)   (affine velocity)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    new_V = SUM weights * g_v_all                            Line 304-305  ║\n║    outer_products = g_v @ dpos^T                            Line 309-311  ║\n║    new_C = 4 * inv_dx * SUM weights * outer_products        Line 315      ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 6: ADVECTION                                                        ║\n║                                                                           ║\n║    x_i = x_i + dt * v_i                                                   ║\n║                                                                           ║\n║  Code: X = X + dt * new_V                                       Line 322  ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\nOUTPUT STATE: X, V, C, F, Jp (updated)"
  },
  {
    "objectID": "mpm-algorithm.html#variable-reference-table",
    "href": "mpm-algorithm.html#variable-reference-table",
    "title": "MPM Algorithm",
    "section": "Variable Reference Table",
    "text": "Variable Reference Table\n\n\n\n\n\n\n\n\n\n\nCode Variable\nMath Symbol\nShape\nPhysical Meaning\nUnits\n\n\n\n\nX\n\\(\\mathbf{x}_i\\)\n[N, 2]\nParticle position\nm\n\n\nV\n\\(\\mathbf{v}_i\\)\n[N, 2]\nParticle velocity\nm/s\n\n\nC\n\\(\\mathbf{C}_i\\)\n[N, 2, 2]\nAffine velocity matrix (velocity gradient)\n1/s\n\n\nF\n\\(\\mathbf{F}_i\\)\n[N, 2, 2]\nDeformation gradient\n-\n\n\nJp\n\\(J_p\\)\n[N, 1]\nPlastic volume ratio (accumulated)\n-\n\n\nT\ntype\n[N, 1]\nMaterial type index\n-\n\n\nM\n\\(m_i\\)\n[N, 1]\nParticle mass\nkg\n\n\nU\n\\(\\mathbf{U}\\)\n[N, 2, 2]\nLeft rotation (from SVD)\n-\n\n\nsig\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2]\nSingular values (stretches)\n-\n\n\nVh\n\\(\\mathbf{V}^T\\)\n[N, 2, 2]\nRight rotation transposed\n-\n\n\nR\n\\(\\mathbf{R}\\)\n[N, 2, 2]\nRotation matrix \\(\\mathbf{U}\\mathbf{V}^T\\)\n-\n\n\nJ\n\\(J\\)\n[N]\nVolume ratio \\(\\det(\\mathbf{F})\\)\n-\n\n\nh\n\\(h\\)\n[N]\nHardening factor\n-\n\n\nmu\n\\(\\mu\\)\n[N]\nShear modulus\nPa\n\n\nla\n\\(\\lambda\\)\n[N]\nFirst Lame parameter\nPa\n\n\nstress\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2, 2]\nCauchy stress (scaled)\nN\n\n\naffine\n\\(\\mathbf{Q}\\)\n[N, 2, 2]\nAffine momentum \\(\\sigma + m\\mathbf{C}\\)\nN\n\n\ngrid_m\n\\(m_j\\)\n[G, G]\nGrid mass (accumulated)\nkg\n\n\ngrid_v\n\\(\\mathbf{p}_j\\)\n[G, G, 2]\nGrid momentum (accumulated, NOT velocity!)\nkg·m/s\n\n\nw\n\\(w\\)\n[N, 3, 2]\nB-spline weights\n-"
  },
  {
    "objectID": "mpm-algorithm.html#key-equations-summary",
    "href": "mpm-algorithm.html#key-equations-summary",
    "title": "MPM Algorithm",
    "section": "Key Equations Summary",
    "text": "Key Equations Summary\n\nDeformation Update\n\\[\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\mathbf{F}^n\\]\n\n\nSVD Decomposition\n\\[\\mathbf{F} = \\mathbf{U} \\, \\text{diag}(\\sigma_1, \\sigma_2) \\, \\mathbf{V}^T\\]\n\n\nHardening (Snow)\n\\[h = \\exp\\bigl(10(1 - J_p)\\bigr)\\]\n\n\nLame Parameters\n\\[\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\\]\n\n\nCauchy Stress (Fixed Corotated)\n\\[\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\\]\n\n\nAffine Momentum\n\\[\\mathbf{Q} = \\boldsymbol{\\sigma}_{\\text{scaled}} + m \\, \\mathbf{C}\\]\n\n\nP2G Transfer\nStep 1: Each particle contributes to neighboring grid nodes \\[\\delta m_j = w_j \\, m_i, \\quad \\delta \\mathbf{p}_j = w_j \\bigl(m_i \\mathbf{v}_i + \\mathbf{Q} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)\\bigr)\\]\nStep 2: GNN accumulates all contributions at each node \\[m_j = \\sum_i \\delta m_j, \\quad \\mathbf{p}_j = \\sum_i \\delta \\mathbf{p}_j\\]\n\n\nGrid Operations (uses accumulated values)\n\\[\\mathbf{v}_j = \\mathbf{p}_j / m_j \\quad \\text{(momentum} \\to \\text{velocity)}\\]\n\n\nG2P Transfer (APIC)\n\\[\\mathbf{v}_i = \\sum_j w_j \\, \\mathbf{v}_j, \\quad \\mathbf{C}_i = \\frac{4}{\\Delta x^2} \\sum_j w_j \\, \\mathbf{v}_j \\otimes (\\mathbf{x}_j - \\mathbf{x}_i)\\]\n\n\nAdvection\n\\[\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\Delta t \\, \\mathbf{v}^{n+1}\\]"
  },
  {
    "objectID": "mpm-algorithm.html#the-affine-term-explained",
    "href": "mpm-algorithm.html#the-affine-term-explained",
    "title": "MPM Algorithm",
    "section": "The Affine Term Explained",
    "text": "The Affine Term Explained\nThe key insight is that affine = stress + m·C combines two physical effects:\n\n\n\n\n\n\nImportantWhy stress + m·C?\n\n\n\n\nstress term: Internal forces from material deformation. This is what creates elastic/plastic behavior.\nm·C term: The APIC (Affine Particle-In-Cell) contribution. This preserves angular momentum and prevents numerical dissipation.\n\nEach particle’s contribution to grid momentum is: \\[\\delta \\mathbf{p}_j = w_j \\cdot \\bigl[\\underbrace{m_i \\mathbf{v}_i}_{\\text{linear momentum}} + \\underbrace{\\mathbf{Q}}_{\\text{affine}} \\cdot \\underbrace{(\\mathbf{x}_j - \\mathbf{x}_i)}_{\\text{dpos}}\\bigr]\\]\nThis single transfer carries both force (from stress) and momentum gradient (from C) information."
  }
]