[
  {
    "objectID": "p2g-g2p.html",
    "href": "p2g-g2p.html",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#overview",
    "href": "p2g-g2p.html#overview",
    "title": "P2G & G2P Transfers",
    "section": "",
    "text": "The key innovation of MPM is the bidirectional transfer between particles and grid:\n\nP2G (Particle-to-Grid): Scatter particle mass and momentum to grid\nG2P (Grid-to-Particle): Gather updated velocities back to particles\n\n\n\n\n\n\n\n\n\n\nTransfer\nDirection\nWhat is transferred\nFormula\n\n\n\n\nP2G\nParticle → Grid\nMass, momentum\n\\(\\Delta m_j = w_j \\cdot m_i\\), \\(\\Delta p_j = w_j (m_i v_i + Q_i \\cdot dx)\\)\n\n\nG2P\nGrid → Particle\nVelocity, affine matrix\n\\(v_i = \\sum_j w_j v_j\\), \\(C_i = 4/dx^2 \\sum_j w_j v_j \\otimes dx\\)"
  },
  {
    "objectID": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "href": "p2g-g2p.html#quadratic-b-spline-interpolation",
    "title": "P2G & G2P Transfers",
    "section": "Quadratic B-Spline Interpolation",
    "text": "Quadratic B-Spline Interpolation\nEach particle interacts with a 3×3 stencil of neighboring grid nodes (in 2D).\n\nFinding the Base Node\nFor particle at position \\(\\mathbf{x}_i\\):\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i \\cdot n_{\\text{grid}} - 0.5 \\rfloor\n\\]\n\n\nFractional Position\n\\[\n\\mathbf{f}_x = \\mathbf{x}_i \\cdot n_{\\text{grid}} - \\mathbf{j}_{\\text{base}}\n\\]\nThis gives the particle’s position within its local cell, with \\(\\mathbf{f}_x \\in [0.5, 1.5]\\).\n\n\nWeight Functions\nThe quadratic B-spline weights ensure \\(C^1\\) continuity:\n\n\n\nWeight\nFormula\nRange\n\n\n\n\n\\(w_0\\)\n\\(0.5(1.5 - f_x)^2\\)\nNode at base\n\n\n\\(w_1\\)\n\\(0.75 - (f_x - 1)^2\\)\nNode at base+1\n\n\n\\(w_2\\)\n\\(0.5(f_x - 0.5)^2\\)\nNode at base+2\n\n\n\nFor 2D, the combined weight is:\n\\[\nw_{jk} = w_j(f_{x,1}) \\cdot w_k(f_{x,2})\n\\]\n\n\n\n\n\n\nTipProperties of B-Spline Weights\n\n\n\n\nPartition of unity: \\(\\sum_j w_j = 1\\)\nNon-negative: \\(w_j \\geq 0\\)\nCompact support: Only 9 non-zero weights per particle (2D)"
  },
  {
    "objectID": "p2g-g2p.html#p2g-transfer-details",
    "href": "p2g-g2p.html#p2g-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "P2G Transfer Details",
    "text": "P2G Transfer Details\n\nMass Transfer\nEach particle distributes its mass to neighboring nodes:\n\\[\n\\Delta m_{\\mathbf{j}} = w_{\\mathbf{j}} \\cdot m_i\n\\]\n\n\nMomentum Transfer (APIC)\nThe Affine Particle-In-Cell (APIC) method transfers both linear and angular momentum:\n\\[\n\\Delta \\mathbf{p}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nwhere: - \\(\\mathbf{d}_{i\\mathbf{j}} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\\) is the offset vector - \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum matrix\n\n\nStress Contribution\nThe stress tensor is scaled for P2G:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\nwhere \\(V_p\\) is the particle volume."
  },
  {
    "objectID": "p2g-g2p.html#g2p-transfer-details",
    "href": "p2g-g2p.html#g2p-transfer-details",
    "title": "P2G & G2P Transfers",
    "section": "G2P Transfer Details",
    "text": "G2P Transfer Details\n\nVelocity Update\n\\[\n\\mathbf{v}_i^{\\text{new}} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}}^{\\text{grid}}\n\\]\n\n\nAffine Velocity Matrix (APIC)\nThe local velocity gradient is reconstructed:\n\\[\n\\mathbf{C}_i^{\\text{new}} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\cdot \\mathbf{v}_{\\mathbf{j}} \\otimes \\mathbf{d}_{\\mathbf{j}i}\n\\]\nwhere \\(\\mathbf{d}_{\\mathbf{j}i} = (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) / \\Delta x\\) is the normalized offset.\n\n\n\n\n\n\nNoteWhy APIC?\n\n\n\nThe Affine Particle-In-Cell method: - Conserves angular momentum exactly - Eliminates numerical damping from traditional PIC/FLIP - Provides smoother, more stable simulations"
  },
  {
    "objectID": "p2g-g2p.html#gnn-implementation",
    "href": "p2g-g2p.html#gnn-implementation",
    "title": "P2G & G2P Transfers",
    "section": "GNN Implementation",
    "text": "GNN Implementation\nIn this codebase, P2G is implemented using a Graph Neural Network for flexibility:\n\nGraph Structure\nNodes: V = V_particles ∪ V_grid\nEdges: E = {(i, j) : j ∈ 3×3 neighborhood of particle i}\n\n\nNode Features\n\n\n\nNode Type\nFeatures\n\n\n\n\nParticle\n\\((m_i, v_{i,x}, v_{i,y})\\)\n\n\nGrid\n\\((0, 0, 0)\\) initially\n\n\n\n\n\nEdge Features\n\n\n\nFeature\nDescription\n\n\n\n\nweights_per_edge\nB-spline weight \\(w_{ij}\\)\n\n\naffine_per_edge\nAffine matrix \\(\\mathbf{Q}_i\\)\n\n\ndpos_per_edge\nOffset \\((\\mathbf{x}_j - \\mathbf{x}_i)\\)\n\n\n\n\n\nMessage Passing\nThe GNN aggregates particle contributions:\n\\[\n\\mathbf{m}_{\\mathbf{j}} = \\sum_{i : (i,\\mathbf{j}) \\in E} w_{i\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i \\cdot \\mathbf{d}_{i\\mathbf{j}} \\right)\n\\]\nThis sum aggregation produces grid mass and momentum."
  },
  {
    "objectID": "p2g-g2p.html#implementation-in-code",
    "href": "p2g-g2p.html#implementation-in-code",
    "title": "P2G & G2P Transfers",
    "section": "Implementation in Code",
    "text": "Implementation in Code\n\nP2G (from MPM_step.py)\n# Compute base index and fractional position\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n\nG2P (from MPM_step.py)\n# Accumulate velocity from grid neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\nouter_products = torch.bmm(g_v_flat, dpos_flat)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)"
  },
  {
    "objectID": "materials.html",
    "href": "materials.html",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#overview",
    "href": "materials.html#overview",
    "title": "Material Types",
    "section": "",
    "text": "MPM PyTorch supports three distinct material types, each with different physical behaviors:\n\n\n\nType\nID\nShear\nPlasticity\nUse Cases\n\n\n\n\nLiquid\n0\nNone\nNone\nWater, fluids\n\n\nJelly\n1\nFixed\nNone\nElastic solids\n\n\nSnow\n2\nVariable\nYes\nGranular materials"
  },
  {
    "objectID": "materials.html#material-masks",
    "href": "materials.html#material-masks",
    "title": "Material Types",
    "section": "Material Masks",
    "text": "Material Masks\nIn the code, materials are distinguished by type ID:\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)"
  },
  {
    "objectID": "materials.html#liquid-t-0",
    "href": "materials.html#liquid-t-0",
    "title": "Material Types",
    "section": "Liquid (\\(T = 0\\))",
    "text": "Liquid (\\(T = 0\\))\nLiquids are incompressible fluids with no resistance to shear deformation.\n\nProperties\n\nShear modulus: \\(\\mu = 0\\)\nDeformation: Isotropic only\n\n\n\nDeformation Gradient\nFor liquids, the deformation gradient is reset to preserve only volume:\n\\[\n\\mathbf{F}^{\\text{liquid}} = \\sqrt{J} \\cdot \\mathbf{I}\n\\]\nwhere \\(J = \\det(\\mathbf{F})\\) is the volume ratio.\n\n\n\n\n\n\nNotePhysical Interpretation\n\n\n\nThis ensures liquids have no “shape memory”—they flow to fill any container while preserving volume (incompressibility).\n\n\n\n\nSurface Tension (Optional)\nWhen enabled, surface tension creates cohesive forces between liquid particles:\n\\[\n\\boldsymbol{\\sigma}_{\\text{surface}} = -\\gamma \\cdot s \\cdot (\\mathbf{n} \\otimes \\mathbf{n})\n\\]\nwhere: - \\(\\gamma\\) is the surface tension coefficient - \\(s\\) measures how much of a “surface particle” each particle is - \\(\\mathbf{n}\\) is the direction toward the local center of mass"
  },
  {
    "objectID": "materials.html#jelly-t-1",
    "href": "materials.html#jelly-t-1",
    "title": "Material Types",
    "section": "Jelly (\\(T = 1\\))",
    "text": "Jelly (\\(T = 1\\))\nJelly represents elastic solids that deform and return to their original shape.\n\nProperties\n\nHardening factor: Fixed at \\(h = 0.3\\) (70% softer than reference)\nFull elastic response: Both shear and bulk resistance\n\n\n\nStress Response\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nThe rotation \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is extracted from SVD of \\(\\mathbf{F}\\).\n\n\n\n\n\n\nTipJelly Behavior\n\n\n\n\nBounces back after deformation\nPreserves shape memory\nNo permanent (plastic) deformation"
  },
  {
    "objectID": "materials.html#snow-t-2",
    "href": "materials.html#snow-t-2",
    "title": "Material Types",
    "section": "Snow (\\(T = 2\\))",
    "text": "Snow (\\(T = 2\\))\nSnow exhibits elastoplastic behavior with hardening and softening.\n\nPlasticity Model\nThe singular values of \\(\\mathbf{F}\\) are clamped to limit elastic deformation:\n\\[\n\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, 1 - 2.5 \\times 10^{-2}, 1 + 4.5 \\times 10^{-3})\n\\]\n\n\n\nLimit\nValue\nMeaning\n\n\n\n\nLower\n0.975\nMax 2.5% compression before plastic flow\n\n\nUpper\n1.0045\nMax 0.45% stretch before plastic flow\n\n\n\n\n\nPlastic Volume Accumulation\n\\[\nJ_p^{\\text{new}} = J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\n\\]\nThis tracks cumulative plastic deformation.\n\n\nHardening\nThe hardening factor depends on plastic history:\n\\[\nh = \\exp(10 \\cdot (1 - J_p))\n\\]\n\n\n\n\\(J_p\\)\n\\(h\\)\nMaterial State\n\n\n\n\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nCompressed, harder\n\n\n\\(= 1\\)\n\\(= 1\\)\nReference state\n\n\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nExpanded, softer\n\n\n\n\n\nReconstructed Deformation\nAfter plasticity projection:\n\\[\n\\mathbf{F}^{\\text{snow}} = \\mathbf{U} \\cdot \\text{diag}(\\sigma_k^{\\text{new}}) \\cdot \\mathbf{V}^T\n\\]"
  },
  {
    "objectID": "materials.html#material-parameters",
    "href": "materials.html#material-parameters",
    "title": "Material Types",
    "section": "Material Parameters",
    "text": "Material Parameters\n\nLame Parameters\nFrom Young’s modulus \\(E\\) and Poisson’s ratio \\(\\nu\\):\n\\[\n\\mu_0 = \\frac{E}{2(1+\\nu)}, \\quad \\lambda_0 = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n\\]\n\n\nDefault Values\n\n\n\nParameter\nSymbol\nValue\n\n\n\n\nYoung’s modulus\n\\(E\\)\n\\(10^3\\) Pa\n\n\nPoisson’s ratio\n\\(\\nu\\)\n0.2\n\n\nShear modulus\n\\(\\mu_0\\)\n417 Pa\n\n\nLame first\n\\(\\lambda_0\\)\n278 Pa\n\n\n\n\n\nMaterial-Specific Adjustments\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\n\n# Jelly: fixed softness\nh = torch.where(jelly_mask, 0.3, h)\n\n# Apply to Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\n\n# Liquids: no shear\nmu = torch.where(liquid_mask, 0.0, mu)"
  },
  {
    "objectID": "materials.html#density-and-mass",
    "href": "materials.html#density-and-mass",
    "title": "Material Types",
    "section": "Density and Mass",
    "text": "Density and Mass\nDifferent materials can have different densities:\n# Config example\nsimulation:\n  MPM_rho_list: [1000, 1200, 400]  # [liquid, jelly, snow] kg/m³\nParticle mass is computed as:\n\\[\nm_i = \\rho_{T_i} \\cdot V_p\n\\]\nwhere \\(V_p = (\\Delta x / 2)^2\\) is the particle volume."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MPM PyTorch",
    "section": "",
    "text": "MPM-Pytorch is a differentiable implementation based on taichi_mpm by Yuanming Hu. It provides a fully differentiable MPM solver, enabling:\nThe Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "MPM PyTorch",
    "section": "",
    "text": "MPM-Pytorch is a differentiable implementation based on taichi_mpm by Yuanming Hu. It provides a fully differentiable MPM solver, enabling:\nThe Material Point Method (MPM) is a numerical technique for simulating materials that undergo large deformations, fracture, and complex material interactions. It combines the strengths of both Lagrangian (particle-based) and Eulerian (grid-based) approaches."
  },
  {
    "objectID": "index.html#hybrid-lagrangian-eulerian-approach",
    "href": "index.html#hybrid-lagrangian-eulerian-approach",
    "title": "MPM PyTorch",
    "section": "Hybrid Lagrangian-Eulerian Approach",
    "text": "Hybrid Lagrangian-Eulerian Approach\nMPM uses a hybrid approach where:\n\nParticles carry material state (mass, velocity, deformation history)\nGrid handles momentum transfer and boundary conditions\n\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\nDeformation gradient update: \\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nCauchy stress from constitutive model\n\n\n3\nP2G Transfer\nScatter mass & momentum to grid\n\n\n4\nGrid Operations\nApply gravity, boundary conditions\n\n\n5\nG2P Transfer\nGather velocities back to particles\n\n\n6\nAdvect\nUpdate particle positions: \\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)\n\n\n\nThe cycle repeats for each timestep."
  },
  {
    "objectID": "index.html#particle-state-variables",
    "href": "index.html#particle-state-variables",
    "title": "MPM PyTorch",
    "section": "Particle State Variables",
    "text": "Particle State Variables\nEach particle \\(i\\) carries the following quantities:\n\n\n\n\n\n\n\n\n\nSymbol\nVariable\nDimension\nDescription\n\n\n\n\n\\(\\mathbf{x}_i\\)\nPosition\n\\(d\\)\nSpatial location (2D or 3D)\n\n\n\\(\\mathbf{v}_i\\)\nVelocity\n\\(d\\)\nMaterial velocity\n\n\n\\(\\mathbf{C}_i\\)\nAffine velocity\n\\(d \\times d\\)\nLocal velocity gradient (APIC)\n\n\n\\(\\mathbf{F}_i\\)\nDeformation gradient\n\\(d \\times d\\)\nTracks total deformation\n\n\n\\(J_i\\)\nPlastic deformation\n\\(1\\)\nAccumulated plastic volume change\n\n\n\\(m_i\\)\nMass\n\\(1\\)\nParticle mass\n\n\n\\(T_i\\)\nMaterial type\n\\(1\\)\n0=liquid, 1=jelly, 2=snow"
  },
  {
    "objectID": "index.html#material-types",
    "href": "index.html#material-types",
    "title": "MPM PyTorch",
    "section": "Material Types",
    "text": "Material Types\nMPM PyTorch supports three material types with distinct behaviors:\n\nLiquidJelly (Elastic Solid)Snow\n\n\n\nNo shear resistance (\\(\\mu = 0\\))\nIsotropic deformation: \\(\\mathbf{F} = \\sqrt{J} \\, \\mathbf{I}\\)\nOptional surface tension\n\n\n\n\nFixed stiffness (\\(h = 0.3\\))\nFull elastic response\nPreserves shape memory\n\n\n\n\nPlastic deformation with clamped singular values\nHardening/softening based on \\(J_p\\)\nCaptures compression and fracture"
  },
  {
    "objectID": "index.html#key-equations",
    "href": "index.html#key-equations",
    "title": "MPM PyTorch",
    "section": "Key Equations",
    "text": "Key Equations\n\nDeformation Gradient Update\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\n\n\nCauchy Stress (Neo-Hookean)\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation from SVD of \\(\\mathbf{F}\\).\n\n\nParticle Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "index.html#d-simulation-gallery",
    "href": "index.html#d-simulation-gallery",
    "title": "MPM PyTorch",
    "section": "2D Simulation Gallery",
    "text": "2D Simulation Gallery\n\nMulti-Material (3 types)CollisionPincerCells\n\n\n9 discs of different materials (liquid, jelly, snow) falling under gravity.\n\n\n\nTwo discs of different materials colliding.\n\n\n\nLiquid and jelly discs squeezing a center jelly disc.\n\n\n\nSoft cell-like bodies with expansion, simulating biological tissue."
  },
  {
    "objectID": "index.html#d-simulation-gallery-1",
    "href": "index.html#d-simulation-gallery-1",
    "title": "MPM PyTorch",
    "section": "3D Simulation Gallery",
    "text": "3D Simulation Gallery\n\nFalling Cubes\n\n\n27 cubes of particles falling in a 3D box (35,937 particles on 128x128x128 grid)."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "MPM PyTorch",
    "section": "Documentation",
    "text": "Documentation\n\n\n\nPage\nContent\n\n\n\n\nMPM Algorithm\nComplete algorithm overview\n\n\nP2G & G2P Transfers\nParticle-grid interpolation\n\n\nMaterial Types\nLiquid, jelly, snow behaviors\n\n\nConstitutive Models\nStress computation\n\n\nImplementation\nCode walkthrough"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "MPM PyTorch",
    "section": "References",
    "text": "References\n\nStomakhin et al. (2013). “A material point method for snow simulation”\nHu et al. (2018). “A moving least squares material point method with displacement discontinuity and two-way rigid body coupling”\nJiang et al. (2015). “The affine particle-in-cell method”"
  },
  {
    "objectID": "constitutive.html",
    "href": "constitutive.html",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#overview",
    "href": "constitutive.html#overview",
    "title": "Constitutive Models",
    "section": "",
    "text": "The constitutive model relates deformation (\\(\\mathbf{F}\\)) to stress (\\(\\boldsymbol{\\sigma}\\)). MPM PyTorch uses a fixed corotated hyperelastic model with material-specific modifications."
  },
  {
    "objectID": "constitutive.html#deformation-gradient",
    "href": "constitutive.html#deformation-gradient",
    "title": "Constitutive Models",
    "section": "Deformation Gradient",
    "text": "Deformation Gradient\nThe deformation gradient \\(\\mathbf{F}\\) is a \\(d \\times d\\) matrix (2×2 in 2D) that maps from reference to deformed configuration:\n\\[\nd\\mathbf{x} = \\mathbf{F} \\cdot d\\mathbf{X}\n\\]\n\nUpdate Rule\n\\[\n\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\, \\mathbf{F}^n\n\\]\nwhere \\(\\mathbf{C}\\) is the affine velocity matrix (velocity gradient).\n\n\nSVD Decomposition\nFor stress computation and plasticity:\n\\[\n\\mathbf{F} = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\n\n\n\nComponent\nSize\nInterpretation\n\n\n\n\n\\(\\mathbf{U}\\)\n\\(d \\times d\\)\nLeft rotation\n\n\n\\(\\boldsymbol{\\Sigma}\\)\n\\(d \\times d\\)\nStretch (diagonal)\n\n\n\\(\\mathbf{V}^T\\)\n\\(d \\times d\\)\nRight rotation\n\n\n\n\n\nKey Quantities\n\n\n\nSymbol\nFormula\nMeaning\n\n\n\n\n\\(J\\)\n\\(\\det(\\mathbf{F}) = \\prod_k \\sigma_k\\)\nVolume ratio\n\n\n\\(\\mathbf{R}\\)\n\\(\\mathbf{U}\\mathbf{V}^T\\)\nRotation component"
  },
  {
    "objectID": "constitutive.html#fixed-corotated-model",
    "href": "constitutive.html#fixed-corotated-model",
    "title": "Constitutive Models",
    "section": "Fixed Corotated Model",
    "text": "Fixed Corotated Model\nThe stress depends on how much \\(\\mathbf{F}\\) deviates from a pure rotation.\n\nFirst Piola-Kirchhoff Stress\n\\[\n\\mathbf{P} = 2\\mu (\\mathbf{F} - \\mathbf{R}) + \\lambda (J - 1) J \\mathbf{F}^{-T}\n\\]\n\n\nCauchy Stress (Used in Code)\n\\[\n\\boldsymbol{\\sigma} = \\frac{1}{J} \\mathbf{P} \\mathbf{F}^T = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\n\n\nComponents\n\n\n\n\n\n\n\nTerm\nPhysical Meaning\n\n\n\n\n\\(2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T\\)\nShear resistance (shape recovery)\n\n\n\\(\\lambda J (J-1) \\mathbf{I}\\)\nBulk resistance (volume recovery)\n\n\n\n\n\n\n\n\n\nNoteWhy “Corotated”?\n\n\n\nThe model measures deformation relative to the rotation \\(\\mathbf{R}\\), making it frame-invariant and stable under large rotations."
  },
  {
    "objectID": "constitutive.html#hardening-model",
    "href": "constitutive.html#hardening-model",
    "title": "Constitutive Models",
    "section": "Hardening Model",
    "text": "Hardening Model\nMaterial stiffness varies with plastic history through the hardening factor \\(h\\):\n\\[\nh = \\exp(10 (1 - J_p))\n\\]\n\nEffect on Lame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\nPhysical Interpretation\n\n\n\nState\n\\(J_p\\)\n\\(h\\)\nMaterial\n\n\n\n\nCompressed\n\\(&lt; 1\\)\n\\(&gt; 1\\)\nStiffer\n\n\nReference\n\\(= 1\\)\n\\(= 1\\)\nNormal\n\n\nExpanded\n\\(&gt; 1\\)\n\\(&lt; 1\\)\nSofter"
  },
  {
    "objectID": "constitutive.html#plasticity-snow-only",
    "href": "constitutive.html#plasticity-snow-only",
    "title": "Constitutive Models",
    "section": "Plasticity (Snow Only)",
    "text": "Plasticity (Snow Only)\nSnow undergoes irreversible plastic deformation when stretched or compressed beyond limits.\n\nYield Surface\nThe singular values are constrained:\n\\[\n\\sigma_k \\in [1 - \\epsilon_c, 1 + \\epsilon_s]\n\\]\n\n\n\nParameter\nValue\nMeaning\n\n\n\n\n\\(\\epsilon_c\\)\n0.025\nCompression limit\n\n\n\\(\\epsilon_s\\)\n0.0045\nStretch limit\n\n\n\n\n\nPlastic Flow\nWhen singular values exceed limits:\n\nClamp to valid range: \\(\\sigma_k^{\\text{new}} = \\text{clamp}(\\sigma_k, ...)\\)\nUpdate plastic deformation: \\(J_p \\leftarrow J_p \\cdot \\prod_k \\frac{\\sigma_k^{\\text{old}}}{\\sigma_k^{\\text{new}}}\\)\nReconstruct: \\(\\mathbf{F} \\leftarrow \\mathbf{U} \\, \\text{diag}(\\sigma_k^{\\text{new}}) \\, \\mathbf{V}^T\\)"
  },
  {
    "objectID": "constitutive.html#stress-scaling-for-mpm",
    "href": "constitutive.html#stress-scaling-for-mpm",
    "title": "Constitutive Models",
    "section": "Stress Scaling for MPM",
    "text": "Stress Scaling for MPM\nThe stress is scaled for P2G momentum transfer:\n\\[\n\\text{stress} = -\\Delta t \\cdot V_p \\cdot 4 \\cdot \\Delta x^{-2} \\cdot \\boldsymbol{\\sigma}\n\\]\n\nAffine Momentum\nThe final quantity transferred to grid:\n\\[\n\\mathbf{Q} = \\text{stress} + m \\, \\mathbf{C}\n\\]"
  },
  {
    "objectID": "constitutive.html#implementation",
    "href": "constitutive.html#implementation",
    "title": "Constitutive Models",
    "section": "Implementation",
    "text": "Implementation\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F_reg)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)))\n\n# Scale for P2G\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass * C"
  },
  {
    "objectID": "constitutive.html#energy-density",
    "href": "constitutive.html#energy-density",
    "title": "Constitutive Models",
    "section": "Energy Density",
    "text": "Energy Density\nThe stored elastic energy (for reference):\n\\[\n\\Psi = \\mu \\|\\mathbf{F} - \\mathbf{R}\\|_F^2 + \\frac{\\lambda}{2}(J-1)^2\n\\]\nThis energy is minimized when: - \\(\\mathbf{F} = \\mathbf{R}\\) (pure rotation, no stretch) - \\(J = 1\\) (no volume change)"
  },
  {
    "objectID": "implementation.html",
    "href": "implementation.html",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#code-structure",
    "href": "implementation.html#code-structure",
    "title": "Implementation",
    "section": "",
    "text": "MPM_pytorch/\n├── run_MPM.py                     # Main entry point\n├── config/                        # YAML configuration files\n│   └── multimaterial/            # Multi-material scenarios\n├── src/MPM_pytorch/\n│   ├── generators/\n│   │   ├── graph_data_generator.py   # Data generation\n│   │   ├── MPM_step.py               # Core MPM algorithm\n│   │   └── utils.py                  # Initialization helpers\n│   ├── models/\n│   │   ├── graph_trainer.py          # Training loops\n│   │   └── utils.py                  # Model utilities\n│   └── utils.py                      # General utilities\n└── graphs_data/                   # Generated simulation data"
  },
  {
    "objectID": "implementation.html#key-files",
    "href": "implementation.html#key-files",
    "title": "Implementation",
    "section": "Key Files",
    "text": "Key Files\n\nMPM_step.py - Core Algorithm\nThe heart of the simulation. Contains:\n\nMPM_step(): Complete time step\ncompute_surface_tension_stress(): Liquid surface tension\n\n\n\ngraph_data_generator.py - Simulation Runner\nOrchestrates the full simulation:\n\ndata_generate_MPM_2D(): 2D simulation loop\nInitialization of particle states\nFrame-by-frame stepping\nVisualization output"
  },
  {
    "objectID": "implementation.html#mpm-step-implementation",
    "href": "implementation.html#mpm-step-implementation",
    "title": "Implementation",
    "section": "MPM Step Implementation",
    "text": "MPM Step Implementation\n\nFunction Signature\ndef MPM_step(\n    model_MPM,      # GNN model for P2G\n    X, V, C, F, Jp, T, M,  # Particle states\n    n_particles, n_grid,   # Dimensions\n    dt, dx, inv_dx,        # Time/space steps\n    mu_0, lambda_0,        # Material parameters\n    p_vol, offsets, particle_offsets,\n    expansion_factor, gravity, friction,\n    frame,\n    surface_tension_coeff, tension_scaling,\n    enable_surface_tension, debug_surface,\n    device\n):\n\n\nPhase 1: Deformation Update\n# Material masks\nliquid_mask = (T.squeeze() == 0)\njelly_mask = (T.squeeze() == 1)\nsnow_mask = (T.squeeze() == 2)\n\n# Update deformation gradient\nidentity = torch.eye(2, device=device).unsqueeze(0)\nF = (identity + dt * C) @ F\n\n# Hardening factor\nh = torch.exp(10 * (1.0 - Jp.squeeze()))\nh = torch.where(jelly_mask, 0.3, h)  # Fixed for jelly\n\n# Lame parameters\nmu = mu_0 * h\nla = lambda_0 * h\nmu = torch.where(liquid_mask, 0.0, mu)  # No shear for liquid\n\n\nPhase 2: SVD and Plasticity\n# SVD decomposition\nU, sig, Vh = torch.linalg.svd(F + 1e-6 * identity)\n\n# Sign corrections for proper rotations\ndet_U = torch.det(U)\nneg_det_U = det_U &lt; 0\nif neg_det_U.any():\n    U[neg_det_U, :, -1] *= -1\n    sig[neg_det_U, -1] *= -1\n\n# Snow plasticity: clamp singular values\nsig = torch.where(\n    snow_mask.unsqueeze(1),\n    torch.clamp(sig, min=1-2.5e-2, max=1+4.5e-3),\n    sig\n)\n\n# Update plastic deformation\nJp = Jp * torch.prod(original_sig / sig, dim=1, keepdim=True)\n\n\nPhase 3: Stress Computation\n# Volume ratio\nJ = torch.prod(sig, dim=1)\nJ = torch.clamp(J, min=1e-4)\n\n# Rotation matrix\nR = U @ Vh\n\n# Cauchy stress (fixed corotated)\nF_minus_R = F - R\nstress = (2 * mu.unsqueeze(-1).unsqueeze(-1) * F_minus_R @ F.transpose(-2, -1) +\n          identity * (la * J * (J - 1)).unsqueeze(-1).unsqueeze(-1))\n\n# Scale for P2G transfer\nstress = (-dt * p_vol * 4 * inv_dx * inv_dx) * stress\n\n# Affine momentum\naffine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C\n\n\nPhase 4: P2G Transfer\n# Base grid node\nbase = (X * inv_dx - 0.5).int()\nfx = X * inv_dx - base.float()\n\n# B-spline weights\nw_0 = 0.5 * (1.5 - fx) ** 2\nw_1 = 0.75 - (fx - 1) ** 2\nw_2 = 0.5 * (fx - 0.5) ** 2\nw = torch.stack([w_0, w_1, w_2], dim=1)\n\n# Combined weights for 9 neighbors\nweights_all = w[:, i_indices, 0] * w[:, j_indices, 1]\n\n# Build graph for GNN\ndataset = data.Data(\n    x=x_,\n    edge_index=edge_index,\n    weights_per_edge=weights_per_edge,\n    affine_per_edge=affine_per_edge,\n    dpos_per_edge=dpos_per_edge\n)\n\n# GNN forward pass\ngrid_output = model_MPM(dataset)[0:n_grid**2]\ngrid_m = grid_output[:, 0].view(n_grid, n_grid)\ngrid_v = grid_output[:, 1:3].view(n_grid, n_grid, 2)\n\n\nPhase 5: Grid Operations\n# Momentum to velocity\nvalid_mass_mask = grid_m &gt; 0\ngrid_v = torch.where(\n    valid_mass_mask.unsqueeze(-1),\n    grid_v / (grid_m.unsqueeze(-1) + 1e-10),\n    grid_v\n)\n\n# Apply gravity\ngravity_force = torch.tensor([0.0, dt * gravity], device=device)\ngrid_v = grid_v + gravity_force\n\n# Boundary conditions\ngrid_v[:, :, 0] = torch.where(left_mask & (grid_v[:, :, 0] &lt; 0), 0.0, grid_v[:, :, 0])\ngrid_v[:, :, 0] = torch.where(right_mask & (grid_v[:, :, 0] &gt; 0), 0.0, grid_v[:, :, 0])\n# ... similar for y-component\n\n\nPhase 6: G2P Transfer\n# Gather velocities from 9 neighbors\nvelocity_contribs = weights_all.unsqueeze(-1) * g_v_all\nnew_V = velocity_contribs.sum(dim=1)\n\n# APIC: reconstruct affine velocity matrix\ng_v_flat = g_v_all.reshape(-1, 2, 1)\ndpos_flat = dpos_all.reshape(-1, 1, 2)\nouter_products = torch.bmm(g_v_flat, dpos_flat).reshape(n_particles, 9, 2, 2)\nweighted_outer = weights_all.unsqueeze(-1).unsqueeze(-1) * outer_products\nnew_C = 4 * inv_dx * weighted_outer.sum(dim=1)\n\n# Advection\nX = X + dt * new_V"
  },
  {
    "objectID": "implementation.html#data-generation",
    "href": "implementation.html#data-generation",
    "title": "Implementation",
    "section": "Data Generation",
    "text": "Data Generation\n\nInitialization (graph_data_generator.py)\ndef data_generate_MPM_2D(config, ...):\n    # Grid parameters\n    n_grid = simulation_config.n_grid\n    dx, inv_dx = 1 / n_grid, float(n_grid)\n\n    # Material parameters\n    E, nu = 0.1e4 / young_coeff, 0.2\n    mu_0 = E / (2 * (1 + nu))\n    lambda_0 = E * nu / ((1 + nu) * (1 - 2 * nu))\n\n    # Initialize particles\n    N, X, V, C, F, T, Jp, M, S, ID = init_MPM_shapes(...)\n\n    # Simulation loop\n    for frame in range(n_frames):\n        X, V, C, F, Jp, T, M, stress, grid_m, grid_v = MPM_step(\n            model_MPM, X, V, C, F, Jp, T, M,\n            n_particles, n_grid, dt, dx, inv_dx,\n            mu_0, lambda_0, p_vol, offsets, particle_offsets,\n            expansion_factor, gravity, friction, frame,\n            surface_tension_coeff, tension_scaling,\n            enable_surface_tension, debug_surface,\n            device\n        )\n\n        # Save frame data\n        x_list.append(...)"
  },
  {
    "objectID": "implementation.html#configuration",
    "href": "implementation.html#configuration",
    "title": "Implementation",
    "section": "Configuration",
    "text": "Configuration\nExample YAML config:\ndescription: \"Multi-material simulation with 3 types\"\ndataset: \"multimaterial/multimaterial_1_discs_3types\"\n\nsimulation:\n  n_particles: 9600\n  n_particle_types: 3\n  n_grid: 128\n  n_frames: 2000\n  delta_t: 1.0E-4\n\n  # Material parameters\n  MPM_n_objects: 3\n  MPM_object_type: [0, 1, 2]  # liquid, jelly, snow\n  MPM_rho_list: [1000, 1200, 400]\n  MPM_young_coeff: 1.0\n  MPM_gravity: -200\n  MPM_friction: 0.5\n  MPM_expansion_factor: 1.0\n  MPM_surface_tension: 0.0\n\ntraining:\n  n_runs: 1\n  device: auto"
  },
  {
    "objectID": "implementation.html#running-simulations",
    "href": "implementation.html#running-simulations",
    "title": "Implementation",
    "section": "Running Simulations",
    "text": "Running Simulations\n# Generate data\npython run_MPM.py -o generate multimaterial_1_discs_3types\n\n# Train INR model\npython run_MPM.py -o train_INR multimaterial_1_discs_3types\n\n# Claude-guided exploration\npython run_MPM.py -o train_INR_Claude multimaterial_1_discs_3types iterations=100"
  },
  {
    "objectID": "llm-exploration.html",
    "href": "llm-exploration.html",
    "title": "LLM-Guided INR Optimization",
    "section": "",
    "text": "This page documents an ongoing LLM-in-the-loop exploration to optimize SIREN (Sinusoidal Representation Network) parameters for representing MPM particle fields over time. The exploration uses UCB tree search to systematically tune hyperparameters for each field type, with the goal of scaling to high frame counts.\n\n\n\n\n\n\nNoteGoal\n\n\n\nScale INR field reconstruction to high frame counts (400, 600, 1000 frames) while maintaining R² &gt; 0.995 for all fields (\\(J_p\\), \\(\\mathbf{F}\\), \\(\\mathbf{C}\\), \\(\\mathbf{S}\\)) for 9000 particles. Prior exploration (130+ sequential iterations) mapped the landscape up to 200 frames. Current phase pushes beyond 200 frames to find optimal configs at production scale."
  },
  {
    "objectID": "llm-exploration.html#overview",
    "href": "llm-exploration.html#overview",
    "title": "LLM-Guided INR Optimization",
    "section": "",
    "text": "This page documents an ongoing LLM-in-the-loop exploration to optimize SIREN (Sinusoidal Representation Network) parameters for representing MPM particle fields over time. The exploration uses UCB tree search to systematically tune hyperparameters for each field type, with the goal of scaling to high frame counts.\n\n\n\n\n\n\nNoteGoal\n\n\n\nScale INR field reconstruction to high frame counts (400, 600, 1000 frames) while maintaining R² &gt; 0.995 for all fields (\\(J_p\\), \\(\\mathbf{F}\\), \\(\\mathbf{C}\\), \\(\\mathbf{S}\\)) for 9000 particles. Prior exploration (130+ sequential iterations) mapped the landscape up to 200 frames. Current phase pushes beyond 200 frames to find optimal configs at production scale."
  },
  {
    "objectID": "llm-exploration.html#siren-architecture",
    "href": "llm-exploration.html#siren-architecture",
    "title": "LLM-Guided INR Optimization",
    "section": "SIREN Architecture",
    "text": "SIREN Architecture\nSIREN (Sinusoidal Representation Network) uses sine activations instead of ReLU, enabling smooth derivatives for representing continuous fields:\n\\[\\phi(x) = \\sin(\\omega_0 \\cdot Wx + b)\\]\n\nInput-Output Mapping\nThe INR maps normalized time and particle positions to field values:\n\\[\n\\text{SIREN}: (t/T, \\, x, \\, y) \\rightarrow \\text{field}(t, x, y)\n\\]\nwhere \\(T\\) = number of frames. Time is normalized to [0, 1], and positions \\((x, y)\\) are scaled by nnr_f_xy_period.\nThree input variants are supported:\n\n\n\n\n\n\n\n\n\nVariant\nInput\nOutput\nUse Case\n\n\n\n\nsiren_id\n\\((t, \\text{id})\\)\nField value for one particle\nIndex-based encoding\n\n\nsiren_t\n\\(t\\) only\nAll particles at once\nFaster but less flexible\n\n\nsiren_txy\n\\((t, x, y)\\)\nField value at position\nPosition-aware encoding\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nArchitecture ranking (from Block 8-9 sequential exploration): siren_t &gt;&gt; siren_txy &gt;&gt; siren_id for Jp, F, and C at 100 frames with 9000 particles. siren_id is unsuitable for large particle counts.\n\n\n\n\nFrequency Parameter (omega_f)\nThe omega_f parameter controls the network’s frequency capacity — higher values capture finer spatial/temporal detail but risk training instability. Optimal omega_f is field-specific and frame-dependent:\n\n\n\n\n\n\n\n\n\n\nField\n100 frames\n200 frames\n400 frames\nTrend\n\n\n\n\nJp\n5–10\n3–7\n5\nNarrow peak at 400f\n\n\nF\n12\n9–10\n8–10\nPlateaus above 200f\n\n\nC\n25\n20\n15\nContinues linear decrease\n\n\nS\n48\n—\n48\nCounter-trend: maintains high omega\n\n\n\nKey rule: ALL fields shift omega_f lower with more frames, except S which maintains high omega. The scaling is NOT linear — it approaches an asymptote. For frames &gt;200, omega_f changes slowly.\n\n\nPeriod Parameters (for siren_txy)\nWhen using position-based input (t, x, y), two scaling parameters control coordinate interpretation:\n\n\n\n\n\n\n\n\nParameter\nFormula\nEffect\n\n\n\n\nnnr_f_T_period\n\\(t_{\\text{norm}} = t / T / \\text{period}\\)\nHigher → expects slower temporal variation\n\n\nnnr_f_xy_period\n\\((x,y)_{\\text{norm}} = (x,y) / \\text{period}\\)\nHigher → expects slower spatial variation\n\n\n\n\n\n\n\n\n\nWarningPeriod Sensitivity\n\n\n\nBoth parameters must stay at 1.0 for F field. T_period=2.0 causes catastrophic degradation (R²=0.790). Temporal smoothing is 6× more damaging than spatial.\n\n\n\n\nTunable Parameters\n\n\n\nParameter\nDescription\nTypical Range\n\n\n\n\nn_training_frames\nFrames encoded in SIREN\n100 → 400 → 1000\n\n\nhidden_dim\nWidth of hidden layers\n256–1280\n\n\nn_layers\nNumber of hidden layers\n2–5\n\n\nomega_f\nSIREN frequency multiplier\n3–50\n\n\nlr_NNR_f\nLearning rate\n1E-5–2E-4\n\n\ntotal_steps\nTraining iterations\n100k–1M"
  },
  {
    "objectID": "llm-exploration.html#exploration-methodology",
    "href": "llm-exploration.html#exploration-methodology",
    "title": "LLM-Guided INR Optimization",
    "section": "Exploration Methodology",
    "text": "Exploration Methodology\n\nUCB Tree Search\nEach iteration proposes one parameter mutation, trains the SIREN, and records the result. A UCB (Upper Confidence Bound) tree tracks the exploration:\n\\[\\text{UCB}(k) = R^2_k + c \\cdot \\sqrt{\\frac{\\ln N}{n_k}}\\]\nwhere \\(c\\) is the exploration constant (default \\(\\sqrt{2}\\)), \\(N\\) is total visits, and \\(n_k\\) is visits to node \\(k\\). Higher \\(c\\) favors exploration of under-visited branches; lower \\(c\\) favors exploitation of known-good configs.\n\n\nBlock Structure\nExploration is organized into blocks of n_iter_block iterations (default 8). At block boundaries:\n\nEdit instructions — add/modify rules based on block findings\nChoose next configuration — change field or increase frame count\nUpdate working memory — confirmed principles, regime comparison table\n\n\n\nParallel Mode\nSince iteration 131, the exploration runs in parallel mode — 4 configs trained simultaneously per batch:\n\n\n\nSlot\nRole\nDescription\n\n\n\n\n0\nexploit\nHighest UCB node, conservative mutation\n\n\n1\nexploit\n2nd highest UCB, or same parent different param\n\n\n2\nexplore\nUnder-visited node, new parameter dimension\n\n\n3\nprinciple-test\nTests/challenges an established principle\n\n\n\n\n\nStrategy Selection\n\n\n\n\n\n\n\n\nCondition\nStrategy\nAction\n\n\n\n\nDefault\nexploit\nHighest UCB node, try mutation\n\n\n3+ consecutive R² ≥ 0.95\nfailure-probe\nExtreme parameter to find boundary\n\n\nn_iter_block/4 consecutive successes\nexplore\nSelect outside recent chain\n\n\n2+ distant nodes with R² &gt; 0.95\nrecombine\nMerge params from both nodes\n\n\n4+ consecutive same param\nswitch-param\nMutate different parameter\n\n\nGood config found\nrobustness-test\nRe-run same config\n\n\n\n\n\nCode Modifications\nThe LLM can also modify Python code (network architecture, training loop) when config-level tuning is insufficient:\n\nSiren_Network.py — architecture changes (skip connections, activations, initialization)\ngraph_trainer.py — training loop changes (optimizer, LR scheduler, gradient clipping, loss function)\n\nCode changes are automatically committed to git with iteration metadata for full traceability and rollback capability."
  },
  {
    "objectID": "llm-exploration.html#field-specific-results",
    "href": "llm-exploration.html#field-specific-results",
    "title": "LLM-Guided INR Optimization",
    "section": "Field-Specific Results",
    "text": "Field-Specific Results\n\n\\(\\mathbf{F}\\) — Deformation Gradient @ 400 frames (Block 1 parallel)\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.99995 with 256×4 @ omega=8, lr=1.2E-4, 320k steps (18.4 min)\n\n\n\n\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n8–10 (flat — insensitive in this range)\n\n\nLR ceiling\n1.2E-4 (2.4× vs 200f, matches ~2.5× per 2× frames rule)\n\n\nDepth\n4 layers MANDATORY\n\n\nSteps/frame\n800 (1000 overtrains)\n\n\nOvertraining\n400k steps (1000/f) at lr=8E-5 WORSE than 320k (800/f)\n\n\n\n\n\n\n\n\n\nNoteF omega_f plateau\n\n\n\nThe omega_f-to-frames scaling is NOT linear: 12(100f) → 9(200f) → 8(400f). It approaches an asymptote. At 400f, omega_f=[8-10] is flat and insensitive. For frames &gt;200, don’t extrapolate linearly.\n\n\n\nVideoKinographUCB Tree\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(J_p\\) — Plastic Deformation @ 400 frames (Block 2 parallel)\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.999996 with 512×3 @ omega=5, lr=2E-4, 600k steps (39.0 min)\nSpeed Pareto: 384×3 @ omega=5, lr=2E-4, 600k steps achieves R²=0.999995 in 26.3 min\n\n\n\n\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n5 (NARROW peak — ±2 causes significant degradation)\n\n\nLR ceiling\n2E-4 (5× from 100f, matches ~2.5× per 2× frames)\n\n\nCapacity\n384 near-equal to 512 at optimal lr\n\n\nSteps\n600k needed (400k for speed Pareto)\n\n\n\n\n\n\n\n\n\nNoteJp omega_f sensitivity\n\n\n\nUnlike F where omega_f is flat in [8-10] at 400f, Jp has a narrow omega_f optimum at 5 — both 3 and 7 cause significant MSE degradation (5× and 14× respectively). Jp requires precise omega_f tuning.\n\n\n\nVideoKinographUCB Tree\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{C}\\) — Affine Velocity @ 400 frames (Block 3 parallel)\n\n\n\n\n\n\nTipBest Configuration\n\n\n\nR² = 0.9998 with 896×3 @ omega=15, lr=4E-5, 1M steps (155.8 min)\nSpeed Pareto: 768×3 achieves similar quality in 120.6 min\n\n\n\n\n\n\n\n\n\nFinding\nValue\n\n\n\n\nOptimal omega_f\n15 (continues linear decrease: 25→20→15)\n\n\nLR\n4E-5 (weaker data scaling than F/Jp: ~2× per 4× frames)\n\n\nCapacity\n768–896 (ceiling lifts from 640 at 100f)\n\n\nSteps/frame\n2500 minimum (no overtraining risk, loss still declining at 1M)\n\n\n\n\n\n\n\n\n\nWarningC reverses degradation trend at 400f\n\n\n\nPrior data scaling trend was negative: R²=0.994(100f) → 0.991(200f). But at 400f: R²=0.9998 — a dramatic improvement. With sufficient capacity (896) and steps (1M), C benefits enormously from more data. The 200f degradation was due to insufficient training, not a fundamental limitation.\n\n\n\nVideoKinographUCB Tree\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mathbf{S}\\) — Stress @ 400 frames (Block 4 parallel — in progress)\n\n\n\n\n\n\nWarningCurrently Exploring\n\n\n\nBest so far: R² = 0.960 with 1280×3 @ omega=48, lr=2E-5, 1M steps (290 min)\nKey findings (iterations 25-28):\n\nS@400f baseline R²=0.960 — massive improvement over S@100f (0.729) with CosineAnnealingLR scheduler\nS does NOT follow omega_f decrease pattern — omega_f=48 confirmed optimal\nS lr=2E-5 is HARD-LOCKED (even 50% increase to 3E-5 is catastrophic)\nS requires 1280 capacity minimum (1024 loses 4.4% R²)\nTraining time is 290 min — prohibitively expensive\nLoss still declining at 1M steps (more training may help)\n\n\n\n\nVideoKinographFinal Field (latest S)"
  },
  {
    "objectID": "llm-exploration.html#sequential-phase-results-100200-frames",
    "href": "llm-exploration.html#sequential-phase-results-100200-frames",
    "title": "LLM-Guided INR Optimization",
    "section": "Sequential Phase Results (100–200 frames)",
    "text": "Sequential Phase Results (100–200 frames)\nThe sequential exploration (iterations 1–130) mapped the INR landscape at 100 and 200 frames. Videos from this phase are no longer available, but the parameter maps are fully documented.\n\n100-frame Optimal Configurations\n\n\n\n\n\n\n\n\n\n\n\n\n\nField\nhidden_dim\nn_layers\nomega_f\nlr_NNR_f\ntotal_steps\nR²\nTime (min)\n\n\n\n\nF\n256\n4\n12.0\n4-6E-5\n150k\n0.998\n8.1\n\n\nJp\n512 (384 speed)\n3\n5-10\n4E-5\n200k\n0.996\n15.4 (12.2)\n\n\nC\n640\n3\n25.0\n2E-5\n150k\n0.994\n15.7\n\n\nS\n1280\n3\n48.0\n2E-5\n300k\n0.729\n166.2\n\n\n\n\n\n200-frame Optimal Configurations\n\n\n\n\n\n\n\n\n\n\n\n\n\nField\nhidden_dim\nn_layers\nomega_f\nlr_NNR_f\ntotal_steps\nR²\nTime (min)\n\n\n\n\nF\n256\n4\n9.0\n5E-5\n300k\n0.9997\n32.4\n\n\nJp\n512\n3\n5\n1E-4\n300k\n0.997\n40.5\n\n\n\n\n\nKey Sequential Findings\n\nF omega_f sharp optimum at 100f: omega_f=12 is a LOCAL MAXIMUM — even ±1 degrades. Wider tolerance at 200f (9-10).\nJp omega_f extremely flat at 200f: Range [3-7] all yield R²=0.992–0.997.\nF data scaling: No diminishing returns from 100→200 frames when omega_f re-tuned (R²=0.998→0.9997).\nC degrades at 200f: R²=0.994(100f) → 0.991(200f) — reversed at 400f.\nS@100f ceiling: R²=0.729 without LR scheduler (extreme stochastic variance R²=0.08–0.80).\nsiren_t dominance (Blocks 8-9): siren_t &gt;&gt; siren_txy for Jp (0.99995 vs 0.996), F (1.000 vs 0.998), C (0.9999 vs 0.994) at 100 frames."
  },
  {
    "objectID": "llm-exploration.html#key-discoveries",
    "href": "llm-exploration.html#key-discoveries",
    "title": "LLM-Guided INR Optimization",
    "section": "Key Discoveries",
    "text": "Key Discoveries\n\n\n\nField\nomega_f @ 400f\nArchitecture\nBest R²\nStatus\n\n\n\n\nJp\n5\n512×3 (384 speed)\n0.999996\nMapped\n\n\nF\n8–10\n256×4\n0.99995\nMapped\n\n\nC\n15\n896×3 (768 speed)\n0.9998\nMapped\n\n\nS\n48\n1280×3\n0.960\nIn progress\n\n\n\n\nData Scaling Rules\n\n\nLearning Rate Ceiling vs Frames\n\n\n\nField\n100f\n200f\n400f\nRule\n\n\n\n\nF\n—\n5E-5\n1.2E-4\n~2.5× per 2× frames\n\n\nJp\n4E-5\n1E-4\n2E-4\n~2.5× per 2× frames\n\n\nC\n2E-5\n—\n4E-5\nWeaker (~2× per 4×)\n\n\nS\n2E-5\n—\n2E-5\nHARD-LOCKED\n\n\n\n\n\n\nomega_f vs Frames\n\n\n\nField\n100f\n200f\n400f\nTrend\n\n\n\n\nF\n12\n9\n8\nPlateau\n\n\nJp\n5-10\n3-7\n5\nNarrow peak\n\n\nC\n25\n20\n15\nLinear decrease\n\n\nS\n48\n—\n48\nNo change\n\n\n\n\n\n\n\nEstablished Principles\n\nField-specific architectures required: Jp, F, C, S need DIFFERENT optimal configs on the same dataset\nomega_f scales with field complexity: Jp(5) &lt; F(8-10) &lt; C(15) &lt; S(48) at 400 frames\nMore frames → lower omega_f: All fields except S. Scaling is non-linear (approaches asymptote for F)\nLR ceiling scales ~2.5× per 2× frames: Confirmed for F and Jp. Weaker for C (~2× per 4× frames). S does not follow\nCapacity requirements vary: F(256) &lt; Jp(384-512) &lt; C(768-896) &lt; S(1280)\nDepth is field-locked: Jp(3), F(4), C(3), S(3) — only F benefits from 4 layers\nPeriod parameters must be 1.0: T_period and xy_period deviations cause catastrophic F degradation\nC reverses degradation at 400f: With sufficient capacity + steps, C benefits enormously from more data (0.994→0.991→0.9998)\nS requires CosineAnnealingLR: Without scheduler, R² ceiling is 0.729. With it: 0.960\nLR-steps interaction: High lr + many steps = overshoot. When probing high lr, also test reduced steps\nHigher lr fixes underprediction bias: For Jp, slope improves monotonically with lr\nSIREN + normalization incompatible: LayerNorm/BatchNorm destroy SIREN (R²=0.022)\nField difficulty ranking at 400f: F(0.99995) &gt; Jp(0.999996) &gt; C(0.9998) &gt;&gt; S(0.960)\n\n\n\nOvertraining Risk\n\n\n\n\n\n\n\n\nField\nSteps/frame\nNotes\n\n\n\n\nF\n800 at 400f\nDecreasing trend (1500@200f → 800@400f). 1000/f overtrains\n\n\nJp\n1500 at 400f\nNever exceed 2500 steps/frame\n\n\nC\n2500+ at 400f\nNo overtraining risk, loss still declining at 1M steps\n\n\nS\n2500+ at 400f\nLoss still declining at 1M steps, 290 min training"
  },
  {
    "objectID": "llm-exploration.html#exploration-progress",
    "href": "llm-exploration.html#exploration-progress",
    "title": "LLM-Guided INR Optimization",
    "section": "Exploration Progress",
    "text": "Exploration Progress\n\nSequential Phase (iterations 1–130)\n\n\n\nBlock\nField\nINR Type\nn_frames\nIterations\nBest R²\n\n\n\n\n1\nJp\nsiren_txy\n100\n1–12\n0.996\n\n\n2\nF\nsiren_txy\n100\n13–24\n0.998\n\n\n3\nC\nsiren_txy\n100\n25–36\n0.994\n\n\n4\nS\nsiren_txy\n100\n37–48\n0.729\n\n\n5\nF\nsiren_txy\n200\n49–60\n0.9997\n\n\n6\nJp\nsiren_txy\n200\n61–72\n0.997\n\n\n7\nC\nsiren_txy\n200\n73–84\n0.991\n\n\n8–9\nJp,F,C\nsiren_t\n100\n85–108\n0.99995 (Jp)\n\n\n10\nC\nsiren_t\n100\n109–120\n0.9999\n\n\n11+\nVarious\nVarious\n200–500\n121–130\n—\n\n\n\n\n\nParallel Phase (iterations 1–28+, 4 slots per batch)\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlock\nField\nINR Type\nn_frames\nIterations\nBest R²\nkino_R2\nkino_SSIM\n\n\n\n\n1\nF\nsiren_txy\n400\n1–8\n0.99995\n0.9999\n0.9962\n\n\n2\nJp\nsiren_txy\n400\n9–16\n0.999996\n1.0000\n1.0000\n\n\n3\nC\nsiren_txy\n400\n17–24\n0.9998\n0.9998\n1.0000\n\n\n4\nS\nsiren_txy\n400\n25–32\n0.960\n—\n—"
  },
  {
    "objectID": "llm-exploration.html#optimal-configurations-summary",
    "href": "llm-exploration.html#optimal-configurations-summary",
    "title": "LLM-Guided INR Optimization",
    "section": "Optimal Configurations Summary",
    "text": "Optimal Configurations Summary\n\nPer-Field Optimal at 400 Frames (current best)\n\n\n\n\n\n\n\n\n\n\n\n\n\nField\nhidden_dim\nn_layers\nomega_f\nlr_NNR_f\ntotal_steps\nR²\nTime (min)\n\n\n\n\nF\n256\n4\n8.0\n1.2E-4\n320k\n0.99995\n18.4\n\n\nJp\n512 (384 speed)\n3\n5.0\n2E-4\n600k (400k speed)\n0.999996\n39.0 (26.3)\n\n\nC\n896 (768 speed)\n3\n15.0\n4E-5\n1M\n0.9998\n155.8 (120.6)\n\n\nS\n1280\n3\n48.0\n2E-5\n1M\n0.960\n290.1"
  },
  {
    "objectID": "mpm-algorithm.html",
    "href": "mpm-algorithm.html",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#algorithm-overview",
    "href": "mpm-algorithm.html#algorithm-overview",
    "title": "MPM Algorithm",
    "section": "",
    "text": "The MPM time step consists of four main phases executed in sequence:\n\n\n\n\n\n\n\n\nStep\nPhase\nDescription\n\n\n\n\n1\nUpdate F\n\\(\\mathbf{F} \\leftarrow (\\mathbf{I} + \\Delta t \\mathbf{C}) \\mathbf{F}\\)\n\n\n2\nCompute Stress\nSVD, plasticity, Cauchy stress\n\n\n3\nP2G Transfer\nScatter to grid nodes\n\n\n4\nGrid Operations\nGravity, boundaries\n\n\n5\nG2P Transfer\nGather from grid\n\n\n6\nAdvect\n\\(\\mathbf{x} \\leftarrow \\mathbf{x} + \\Delta t \\mathbf{v}\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "href": "mpm-algorithm.html#phase-1-deformation-gradient-update",
    "title": "MPM Algorithm",
    "section": "Phase 1: Deformation Gradient Update",
    "text": "Phase 1: Deformation Gradient Update\nThe deformation gradient \\(\\mathbf{F}\\) tracks how material has deformed from its rest configuration.\n\nUpdate Rule\nUsing the Moving Least Squares (MLS) approximation:\n\\[\n\\mathbf{F}_i^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}_i^n) \\mathbf{F}_i^n\n\\]\nwhere \\(\\mathbf{C}_i\\) is the affine velocity matrix capturing local velocity gradients.\n\n\nSVD Decomposition\nFor plasticity and stability, we decompose:\n\\[\n\\mathbf{F}_i = \\mathbf{U} \\, \\boldsymbol{\\Sigma} \\, \\mathbf{V}^T\n\\]\nwhere: - \\(\\mathbf{U}, \\mathbf{V}\\) are rotation matrices - \\(\\boldsymbol{\\Sigma} = \\text{diag}(\\sigma_1, \\sigma_2)\\) contains singular values (stretches)\n\n\n\n\n\n\nNoteImplementation Note\n\n\n\nThe code uses torch.linalg.svd with sign corrections to ensure proper rotation matrices (det = +1)."
  },
  {
    "objectID": "mpm-algorithm.html#phase-2-stress-computation",
    "href": "mpm-algorithm.html#phase-2-stress-computation",
    "title": "MPM Algorithm",
    "section": "Phase 2: Stress Computation",
    "text": "Phase 2: Stress Computation\n\nHardening Factor\nMaterial stiffness varies with plastic deformation:\n\\[\nh = \\exp(10(1 - J_p))\n\\]\n\n\\(J_p &lt; 1\\) (compression): \\(h &gt; 1\\) (hardening)\n\\(J_p &gt; 1\\) (expansion): \\(h &lt; 1\\) (softening)\n\n\n\nLame Parameters\n\\[\n\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\n\\]\n\n\n\nParameter\nSymbol\nPhysical Meaning\n\n\n\n\n\\(\\mu\\)\nShear modulus\nResistance to shape change\n\n\n\\(\\lambda\\)\nFirst Lame parameter\nResistance to volume change\n\n\n\n\n\nCauchy Stress\nThe fixed corotated hyperelastic model:\n\\[\n\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\n\\]\nwhere: - \\(\\mathbf{R} = \\mathbf{U}\\mathbf{V}^T\\) is the rotation component - \\(J = \\det(\\mathbf{F}) = \\sigma_1 \\cdot \\sigma_2\\) is the volume ratio"
  },
  {
    "objectID": "mpm-algorithm.html#phase-3-p2g-transfer",
    "href": "mpm-algorithm.html#phase-3-p2g-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 3: P2G Transfer",
    "text": "Phase 3: P2G Transfer\nTransfer particle quantities to the background grid using quadratic B-spline weights.\n\nBase Index\n\\[\n\\mathbf{j}_{\\text{base}} = \\lfloor \\mathbf{x}_i / \\Delta x - 0.5 \\rfloor\n\\]\n\n\nB-Spline Weights\nFor fractional position \\(\\mathbf{f}_x = \\mathbf{x}_i / \\Delta x - \\mathbf{j}_{\\text{base}}\\):\n\\[\n\\begin{aligned}\nw_0 &= 0.5(1.5 - f_x)^2 \\\\\nw_1 &= 0.75 - (f_x - 1)^2 \\\\\nw_2 &= 0.5(f_x - 0.5)^2\n\\end{aligned}\n\\]\n\n\nMomentum Transfer\nFor each of the 9 neighboring grid nodes (in 2D):\n\\[\n\\Delta \\mathbf{m}_{\\mathbf{j}} = w_{\\mathbf{j}} \\left( m_i \\mathbf{v}_i + \\mathbf{Q}_i (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i) \\right)\n\\]\nwhere \\(\\mathbf{Q}_i = \\text{stress} + m_i \\mathbf{C}_i\\) is the affine momentum."
  },
  {
    "objectID": "mpm-algorithm.html#phase-4-grid-operations",
    "href": "mpm-algorithm.html#phase-4-grid-operations",
    "title": "MPM Algorithm",
    "section": "Phase 4: Grid Operations",
    "text": "Phase 4: Grid Operations\n\nMomentum to Velocity\n\\[\n\\mathbf{v}_{\\mathbf{j}} = \\frac{\\mathbf{m}_{\\mathbf{j}}}{m_{\\mathbf{j}}}\n\\]\n\n\nGravity\n\\[\n\\mathbf{v}_{\\mathbf{j}} \\leftarrow \\mathbf{v}_{\\mathbf{j}} + \\Delta t \\, \\mathbf{g}\n\\]\n\n\nBoundary Conditions\n\nNormal: Set penetrating velocity to zero\nTangential: Apply friction: \\(\\mathbf{v}_t \\leftarrow (1-\\alpha) \\mathbf{v}_t\\)"
  },
  {
    "objectID": "mpm-algorithm.html#phase-5-g2p-transfer",
    "href": "mpm-algorithm.html#phase-5-g2p-transfer",
    "title": "MPM Algorithm",
    "section": "Phase 5: G2P Transfer",
    "text": "Phase 5: G2P Transfer\n\nVelocity Update (APIC)\n\\[\n\\mathbf{v}_i^{n+1} = \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}}\n\\]\n\n\nAffine Velocity Update\n\\[\n\\mathbf{C}_i^{n+1} = 4 \\Delta x^{-2} \\sum_{\\mathbf{j} \\in \\mathcal{N}} w_{\\mathbf{j}} \\, \\mathbf{v}_{\\mathbf{j}} \\otimes (\\mathbf{x}_{\\mathbf{j}} - \\mathbf{x}_i)\n\\]\nThe outer product captures local velocity gradients."
  },
  {
    "objectID": "mpm-algorithm.html#phase-6-advection",
    "href": "mpm-algorithm.html#phase-6-advection",
    "title": "MPM Algorithm",
    "section": "Phase 6: Advection",
    "text": "Phase 6: Advection\n\\[\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t \\, \\mathbf{v}_i^{n+1}\n\\]"
  },
  {
    "objectID": "mpm-algorithm.html#complete-variable-flow",
    "href": "mpm-algorithm.html#complete-variable-flow",
    "title": "MPM Algorithm",
    "section": "Complete Variable Flow",
    "text": "Complete Variable Flow\nThis diagram shows how variables in MPM_step.py correspond to the mathematical quantities in MPM.\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         MPM TIME STEP VARIABLE FLOW                         │\n└─────────────────────────────────────────────────────────────────────────────┘\n\nINPUT STATE (per particle)\n┌──────────┬─────────────┬──────────────────────────────────────────────────┐\n│ Variable │ Math Symbol │ Description                                      │\n├──────────┼─────────────┼──────────────────────────────────────────────────┤\n│ X        │ xᵢ          │ Position [n_particles, 2]                        │\n│ V        │ vᵢ          │ Velocity [n_particles, 2]                        │\n│ C        │ Cᵢ          │ Affine velocity matrix [n_particles, 2, 2]       │\n│ F        │ Fᵢ          │ Deformation gradient [n_particles, 2, 2]         │\n│ Jp       │ Jₚ          │ Plastic volume ratio [n_particles, 1]            │\n│ T        │ type        │ Material type (0=liquid, 1=jelly, 2=snow)        │\n│ M        │ mᵢ          │ Mass [n_particles, 1]                            │\n└──────────┴─────────────┴──────────────────────────────────────────────────┘\n\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 1: DEFORMATION GRADIENT UPDATE                                      ║\n║                                                                           ║\n║    F = (I + dt*C) @ F                                                     ║\n║                                                                           ║\n║  Code: F = (identity + dt * C) @ F                            Line 49    ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 1-&gt;2: MATERIAL-SPECIFIC F REFINEMENT                                │\n│                                                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐  │\n│  │  SVD DECOMPOSITION                                                  │  │\n│  │                                                                     │  │\n│  │    F = U * Sigma * V^T                                              │  │\n│  │                                                                     │  │\n│  │  Code: U, sig, Vh = torch.linalg.svd(F_reg)            Line 64     │  │\n│  │                                                                     │  │\n│  │  Variables:                                                         │  │\n│  │    U, Vh  -&gt; rotation matrices [n_particles, 2, 2]                  │  │\n│  │    sig    -&gt; singular values (stretches) [n_particles, 2]           │  │\n│  │    J      -&gt; det(F) = sig1*sig2 = torch.prod(sig)                   │  │\n│  └─────────────────────────────────────────────────────────────────────┘  │\n│                                   │                                      │\n│      ┌─────────────────────────────┼─────────────────────────────┐        │\n│      ▼                             ▼                             ▼        │\n│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐  │\n│  │    LIQUID     │          │     JELLY     │          │     SNOW      │  │\n│  │   (T == 0)    │          │   (T == 1)    │          │   (T == 2)    │  │\n│  ├───────────────┤          ├───────────────┤          ├───────────────┤  │\n│  │ mu = 0        │          │ h = 0.3       │          │ h = exp(10*   │  │\n│  │ (no shear)    │          │ (constant)    │          │    (1-Jp))    │  │\n│  │               │          │               │          │               │  │\n│  │ F = sqrt(J)*I │          │ sig clamped   │          │ sig clamped   │  │\n│  │ (isotropic)   │          │ F = U*Sig*V^T │          │ [0.975,1.0045]│  │\n│  │               │          │               │          │ Jp updated    │  │\n│  └───────────────┘          └───────────────┘          └───────────────┘  │\n│      │                             │                             │        │\n│      └─────────────────────────────┼─────────────────────────────┘        │\n│                                    ▼                                      │\n│  Code references:                                                        │\n│    LIQUID:                                                               │\n│      - mu = 0:   mu = torch.where(liquid_mask, 0.0, mu)      Line 57    │\n│      - F:        F_liquid = identity * sqrt(J)               Line 112   │\n│    JELLY:                                                                │\n│      - h = 0.3:  h = torch.where(jelly_mask, 0.3, h)         Line 52    │\n│      - F:        F_solid = U @ sig_diag @ Vh                 Line 113   │\n│    SNOW:                                                                 │\n│      - h:        h = torch.exp(10 * (1.0 - Jp.squeeze()))    Line 51    │\n│      - clamp:    sig = torch.clamp(sig, 1-2.5e-2, 1+4.5e-3)  Line 98    │\n│      - Jp:       Jp = Jp * plastic_ratio                     Line 102   │\n│      - F:        F_solid = U @ sig_diag @ Vh                 Line 113   │\n│    ALL:                                                                  │\n│      - Lame:     mu = mu_0 * h, la = lambda_0 * h            Lines 55-56│\n└───────────────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 2: STRESS COMPUTATION                                               ║\n║                                                                           ║\n║    R = U * V^T                   (rotation component)                     ║\n║                                                                           ║\n║    stress = 2*mu*(F-R)*F^T + la*J*(J-1)*I   (Cauchy, corotated model)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    R = U @ Vh                                                 Line 123   ║\n║    F_minus_R = F - R                                          Line 124   ║\n║    stress = (2*mu*(F-R)@F^T + la*J*(J-1)*I)                  Line 125-126║\n║    stress = (-dt * p_vol * 4 * inv_dx^2) * stress            Line 127    ║\n║                                                                           ║\n║  The scaling factor converts stress to force for P2G transfer             ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n┌───────────────────────────────────────────────────────────────────────────┐\n│  STEP 2-&gt;3: AFFINE MOMENTUM COMPUTATION                                   │\n│                                                                           │\n│  ┌────────────────────────────────────────────────────────────────────┐   │\n│  │                                                                    │   │\n│  │     affine = stress + m * C                                        │   │\n│  │                                                                    │   │\n│  │  Code: affine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C   │   │\n│  │                                                       Line 162    │   │\n│  │                                                                    │   │\n│  │  Physical interpretation:                                          │   │\n│  │    - stress term: internal forces from deformation                 │   │\n│  │    - m*C term: momentum transport (APIC angular momentum)          │   │\n│  │                                                                    │   │\n│  │  This combined \"affine\" carries BOTH force AND momentum info       │   │\n│  │  to the grid in a single transfer.                                 │   │\n│  └────────────────────────────────────────────────────────────────────┘   │\n│                                                                           │\n│  Variables at this point:                                                 │\n│  ┌────────────┬─────────────┬─────────────────────────────────────────┐   │\n│  │ Variable   │ Shape       │ Description                             │   │\n│  ├────────────┼─────────────┼─────────────────────────────────────────┤   │\n│  │ stress     │ [N, 2, 2]   │ Scaled stress (force)                   │   │\n│  │ C          │ [N, 2, 2]   │ Affine velocity matrix                  │   │\n│  │ p_mass     │ [N]         │ Particle mass                           │   │\n│  │ affine     │ [N, 2, 2]   │ Combined force + momentum gradient      │   │\n│  └────────────┴─────────────┴─────────────────────────────────────────┘   │\n└───────────────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 3: P2G TRANSFER (Particle to Grid)                                  ║\n║                                                                           ║\n║  Each particle i CONTRIBUTES to its 9 neighboring grid nodes j:           ║\n║                                                                           ║\n║    contribution to mass:     dm_j = w_j * m_i                             ║\n║    contribution to momentum: dp_j = w_j * (m_i*v_i + Q_i*(x_j - x_i))     ║\n║                                                                           ║\n║  The GNN ACCUMULATES all particle contributions at each grid node:        ║\n║                                                                           ║\n║    m_j = SUM_i dm_j   (total mass at node j)                              ║\n║    p_j = SUM_i dp_j   (total momentum at node j)                          ║\n║                                                                           ║\n║  Code (MPM_P2G.message computes d, GNN aggregation computes SUM):         ║\n║    out_m = mass_j * weights              # dm_j contribution              ║\n║    out_v = weights * (m*v + Q @ dpos)    # dp_j contribution              ║\n║                                                                           ║\n║  After GNN aggregation (Line 214-216):                                    ║\n║    grid_m = accumulated mass m_j     [n_grid, n_grid]                     ║\n║    grid_v = accumulated momentum p_j [n_grid, n_grid, 2] (NOT velocity!)  ║\n║                                                                           ║\n║  Weights: Quadratic B-spline w0, w1, w2                     Lines 178-181 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 4: GRID OPERATIONS                                                  ║\n║                                                                           ║\n║    v_j = p_j / m_j               (momentum -&gt; velocity, using accumulated)║\n║    v_j += dt * g                 (gravity)                                ║\n║    Apply boundary conditions     (friction, no-penetration)               ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    grid_v = grid_v / (grid_m + eps)                         Line 226-228  ║\n║    grid_v = grid_v + gravity_force                          Line 232-234  ║\n║    Boundary handling                                        Lines 242-266 ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 5: G2P TRANSFER                                                     ║\n║                                                                           ║\n║    v_i = SUM_j w_j * v_j              (APIC velocity update)              ║\n║                                                                           ║\n║    C_i = 4/dx^2 * SUM_j w_j * v_j (x) (x_j - x_i)   (affine velocity)     ║\n║                                                                           ║\n║  Code:                                                                    ║\n║    new_V = SUM weights * g_v_all                            Line 304-305  ║\n║    outer_products = g_v @ dpos^T                            Line 309-311  ║\n║    new_C = 4 * inv_dx * SUM weights * outer_products        Line 315      ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\n╔═══════════════════════════════════════════════════════════════════════════╗\n║  STEP 6: ADVECTION                                                        ║\n║                                                                           ║\n║    x_i = x_i + dt * v_i                                                   ║\n║                                                                           ║\n║  Code: X = X + dt * new_V                                       Line 322  ║\n╚═══════════════════════════════════════════════════════════════════════════╝\n                                   │\n                                   ▼\nOUTPUT STATE: X, V, C, F, Jp (updated)"
  },
  {
    "objectID": "mpm-algorithm.html#variable-reference-table",
    "href": "mpm-algorithm.html#variable-reference-table",
    "title": "MPM Algorithm",
    "section": "Variable Reference Table",
    "text": "Variable Reference Table\n\n\n\n\n\n\n\n\n\n\nCode Variable\nMath Symbol\nShape\nPhysical Meaning\nUnits\n\n\n\n\nX\n\\(\\mathbf{x}_i\\)\n[N, 2]\nParticle position\nm\n\n\nV\n\\(\\mathbf{v}_i\\)\n[N, 2]\nParticle velocity\nm/s\n\n\nC\n\\(\\mathbf{C}_i\\)\n[N, 2, 2]\nAffine velocity matrix (velocity gradient)\n1/s\n\n\nF\n\\(\\mathbf{F}_i\\)\n[N, 2, 2]\nDeformation gradient\n-\n\n\nJp\n\\(J_p\\)\n[N, 1]\nPlastic volume ratio (accumulated)\n-\n\n\nT\ntype\n[N, 1]\nMaterial type index\n-\n\n\nM\n\\(m_i\\)\n[N, 1]\nParticle mass\nkg\n\n\nU\n\\(\\mathbf{U}\\)\n[N, 2, 2]\nLeft rotation (from SVD)\n-\n\n\nsig\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2]\nSingular values (stretches)\n-\n\n\nVh\n\\(\\mathbf{V}^T\\)\n[N, 2, 2]\nRight rotation transposed\n-\n\n\nR\n\\(\\mathbf{R}\\)\n[N, 2, 2]\nRotation matrix \\(\\mathbf{U}\\mathbf{V}^T\\)\n-\n\n\nJ\n\\(J\\)\n[N]\nVolume ratio \\(\\det(\\mathbf{F})\\)\n-\n\n\nh\n\\(h\\)\n[N]\nHardening factor\n-\n\n\nmu\n\\(\\mu\\)\n[N]\nShear modulus\nPa\n\n\nla\n\\(\\lambda\\)\n[N]\nFirst Lame parameter\nPa\n\n\nstress\n\\(\\boldsymbol{\\sigma}\\)\n[N, 2, 2]\nCauchy stress (scaled)\nN\n\n\naffine\n\\(\\mathbf{Q}\\)\n[N, 2, 2]\nAffine momentum \\(\\sigma + m\\mathbf{C}\\)\nN\n\n\ngrid_m\n\\(m_j\\)\n[G, G]\nGrid mass (accumulated)\nkg\n\n\ngrid_v\n\\(\\mathbf{p}_j\\)\n[G, G, 2]\nGrid momentum (accumulated, NOT velocity!)\nkg·m/s\n\n\nw\n\\(w\\)\n[N, 3, 2]\nB-spline weights\n-"
  },
  {
    "objectID": "mpm-algorithm.html#key-equations-summary",
    "href": "mpm-algorithm.html#key-equations-summary",
    "title": "MPM Algorithm",
    "section": "Key Equations Summary",
    "text": "Key Equations Summary\n\nDeformation Update\n\\[\\mathbf{F}^{n+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{C}^n) \\mathbf{F}^n\\]\n\n\nSVD Decomposition\n\\[\\mathbf{F} = \\mathbf{U} \\, \\text{diag}(\\sigma_1, \\sigma_2) \\, \\mathbf{V}^T\\]\n\n\nHardening (Snow)\n\\[h = \\exp\\bigl(10(1 - J_p)\\bigr)\\]\n\n\nLame Parameters\n\\[\\mu = \\mu_0 \\cdot h, \\quad \\lambda = \\lambda_0 \\cdot h\\]\n\n\nCauchy Stress (Fixed Corotated)\n\\[\\boldsymbol{\\sigma} = 2\\mu (\\mathbf{F} - \\mathbf{R}) \\mathbf{F}^T + \\lambda J (J-1) \\mathbf{I}\\]\n\n\nAffine Momentum\n\\[\\mathbf{Q} = \\boldsymbol{\\sigma}_{\\text{scaled}} + m \\, \\mathbf{C}\\]\n\n\nP2G Transfer\nStep 1: Each particle contributes to neighboring grid nodes \\[\\delta m_j = w_j \\, m_i, \\quad \\delta \\mathbf{p}_j = w_j \\bigl(m_i \\mathbf{v}_i + \\mathbf{Q} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)\\bigr)\\]\nStep 2: GNN accumulates all contributions at each node \\[m_j = \\sum_i \\delta m_j, \\quad \\mathbf{p}_j = \\sum_i \\delta \\mathbf{p}_j\\]\n\n\nGrid Operations (uses accumulated values)\n\\[\\mathbf{v}_j = \\mathbf{p}_j / m_j \\quad \\text{(momentum} \\to \\text{velocity)}\\]\n\n\nG2P Transfer (APIC)\n\\[\\mathbf{v}_i = \\sum_j w_j \\, \\mathbf{v}_j, \\quad \\mathbf{C}_i = \\frac{4}{\\Delta x^2} \\sum_j w_j \\, \\mathbf{v}_j \\otimes (\\mathbf{x}_j - \\mathbf{x}_i)\\]\n\n\nAdvection\n\\[\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\Delta t \\, \\mathbf{v}^{n+1}\\]"
  },
  {
    "objectID": "mpm-algorithm.html#the-affine-term-explained",
    "href": "mpm-algorithm.html#the-affine-term-explained",
    "title": "MPM Algorithm",
    "section": "The Affine Term Explained",
    "text": "The Affine Term Explained\nThe key insight is that affine = stress + m·C combines two physical effects:\n\n\n\n\n\n\nImportantWhy stress + m·C?\n\n\n\n\nstress term: Internal forces from material deformation. This is what creates elastic/plastic behavior.\nm·C term: The APIC (Affine Particle-In-Cell) contribution. This preserves angular momentum and prevents numerical dissipation.\n\nEach particle’s contribution to grid momentum is: \\[\\delta \\mathbf{p}_j = w_j \\cdot \\bigl[\\underbrace{m_i \\mathbf{v}_i}_{\\text{linear momentum}} + \\underbrace{\\mathbf{Q}}_{\\text{affine}} \\cdot \\underbrace{(\\mathbf{x}_j - \\mathbf{x}_i)}_{\\text{dpos}}\\bigr]\\]\nThis single transfer carries both force (from stress) and momentum gradient (from C) information."
  }
]