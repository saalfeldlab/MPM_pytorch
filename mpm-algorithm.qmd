---
title: "MPM Algorithm"
subtitle: "Complete Time Step Overview"
---

## Algorithm Overview

The MPM time step consists of four main phases executed in sequence:

| Step | Phase | Description |
|:----:|-------|-------------|
| 1 | **Update F** | $\mathbf{F} \leftarrow (\mathbf{I} + \Delta t \mathbf{C}) \mathbf{F}$ |
| 2 | **Compute Stress** | SVD, plasticity, Cauchy stress |
| 3 | **P2G Transfer** | Scatter to grid nodes |
| 4 | **Grid Operations** | Gravity, boundaries |
| 5 | **G2P Transfer** | Gather from grid |
| 6 | **Advect** | $\mathbf{x} \leftarrow \mathbf{x} + \Delta t \mathbf{v}$ |

## Phase 1: Deformation Gradient Update

The deformation gradient $\mathbf{F}$ tracks how material has deformed from its rest configuration.

### Update Rule

Using the Moving Least Squares (MLS) approximation:

$$
\mathbf{F}_i^{n+1} = (\mathbf{I} + \Delta t \, \mathbf{C}_i^n) \mathbf{F}_i^n
$$

where $\mathbf{C}_i$ is the affine velocity matrix capturing local velocity gradients.

### SVD Decomposition

For plasticity and stability, we decompose:

$$
\mathbf{F}_i = \mathbf{U} \, \boldsymbol{\Sigma} \, \mathbf{V}^T
$$

where:
- $\mathbf{U}, \mathbf{V}$ are rotation matrices
- $\boldsymbol{\Sigma} = \text{diag}(\sigma_1, \sigma_2)$ contains singular values (stretches)

::: {.callout-note}
## Implementation Note
The code uses `torch.linalg.svd` with sign corrections to ensure proper rotation matrices (det = +1).
:::

## Phase 2: Stress Computation

### Hardening Factor

Material stiffness varies with plastic deformation:

$$
h = \exp(10(1 - J_p))
$$

- $J_p < 1$ (compression): $h > 1$ (hardening)
- $J_p > 1$ (expansion): $h < 1$ (softening)

### Lame Parameters

$$
\mu = \mu_0 \cdot h, \quad \lambda = \lambda_0 \cdot h
$$

| Parameter | Symbol | Physical Meaning |
|-----------|--------|------------------|
| $\mu$ | Shear modulus | Resistance to shape change |
| $\lambda$ | First Lame parameter | Resistance to volume change |

### Cauchy Stress

The fixed corotated hyperelastic model:

$$
\boldsymbol{\sigma} = 2\mu (\mathbf{F} - \mathbf{R}) \mathbf{F}^T + \lambda J (J-1) \mathbf{I}
$$

where:
- $\mathbf{R} = \mathbf{U}\mathbf{V}^T$ is the rotation component
- $J = \det(\mathbf{F}) = \sigma_1 \cdot \sigma_2$ is the volume ratio

## Phase 3: P2G Transfer

Transfer particle quantities to the background grid using quadratic B-spline weights.

### Base Index

$$
\mathbf{j}_{\text{base}} = \lfloor \mathbf{x}_i / \Delta x - 0.5 \rfloor
$$

### B-Spline Weights

For fractional position $\mathbf{f}_x = \mathbf{x}_i / \Delta x - \mathbf{j}_{\text{base}}$:

$$
\begin{aligned}
w_0 &= 0.5(1.5 - f_x)^2 \\
w_1 &= 0.75 - (f_x - 1)^2 \\
w_2 &= 0.5(f_x - 0.5)^2
\end{aligned}
$$

### Momentum Transfer

For each of the 9 neighboring grid nodes (in 2D):

$$
\Delta \mathbf{m}_{\mathbf{j}} = w_{\mathbf{j}} \left( m_i \mathbf{v}_i + \mathbf{Q}_i (\mathbf{x}_{\mathbf{j}} - \mathbf{x}_i) \right)
$$

where $\mathbf{Q}_i = \text{stress} + m_i \mathbf{C}_i$ is the affine momentum.

## Phase 4: Grid Operations

### Momentum to Velocity

$$
\mathbf{v}_{\mathbf{j}} = \frac{\mathbf{m}_{\mathbf{j}}}{m_{\mathbf{j}}}
$$

### Gravity

$$
\mathbf{v}_{\mathbf{j}} \leftarrow \mathbf{v}_{\mathbf{j}} + \Delta t \, \mathbf{g}
$$

### Boundary Conditions

- **Normal**: Set penetrating velocity to zero
- **Tangential**: Apply friction: $\mathbf{v}_t \leftarrow (1-\alpha) \mathbf{v}_t$

## Phase 5: G2P Transfer

### Velocity Update (APIC)

$$
\mathbf{v}_i^{n+1} = \sum_{\mathbf{j} \in \mathcal{N}} w_{\mathbf{j}} \, \mathbf{v}_{\mathbf{j}}
$$

### Affine Velocity Update

$$
\mathbf{C}_i^{n+1} = 4 \Delta x^{-2} \sum_{\mathbf{j} \in \mathcal{N}} w_{\mathbf{j}} \, \mathbf{v}_{\mathbf{j}} \otimes (\mathbf{x}_{\mathbf{j}} - \mathbf{x}_i)
$$

The outer product captures local velocity gradients.

## Phase 6: Advection

$$
\mathbf{x}_i^{n+1} = \mathbf{x}_i^n + \Delta t \, \mathbf{v}_i^{n+1}
$$

## Complete Variable Flow

This diagram shows how variables in `MPM_step.py` correspond to the mathematical quantities in MPM.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         MPM TIME STEP VARIABLE FLOW                         │
└─────────────────────────────────────────────────────────────────────────────┘

INPUT STATE (per particle)
┌──────────┬─────────────┬──────────────────────────────────────────────────┐
│ Variable │ Math Symbol │ Description                                      │
├──────────┼─────────────┼──────────────────────────────────────────────────┤
│ X        │ xᵢ          │ Position [n_particles, 2]                        │
│ V        │ vᵢ          │ Velocity [n_particles, 2]                        │
│ C        │ Cᵢ          │ Affine velocity matrix [n_particles, 2, 2]       │
│ F        │ Fᵢ          │ Deformation gradient [n_particles, 2, 2]         │
│ Jp       │ Jₚ          │ Plastic volume ratio [n_particles, 1]            │
│ T        │ type        │ Material type (0=liquid, 1=jelly, 2=snow)        │
│ M        │ mᵢ          │ Mass [n_particles, 1]                            │
└──────────┴─────────────┴──────────────────────────────────────────────────┘

                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 1: DEFORMATION GRADIENT UPDATE                                      ║
║                                                                           ║
║    F = (I + dt*C) @ F                                                     ║
║                                                                           ║
║  Code: F = (identity + dt * C) @ F                            Line 49    ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
┌───────────────────────────────────────────────────────────────────────────┐
│  STEP 1->2: MATERIAL-SPECIFIC F REFINEMENT                                │
│                                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐  │
│  │  SVD DECOMPOSITION                                                  │  │
│  │                                                                     │  │
│  │    F = U * Sigma * V^T                                              │  │
│  │                                                                     │  │
│  │  Code: U, sig, Vh = torch.linalg.svd(F_reg)            Line 64     │  │
│  │                                                                     │  │
│  │  Variables:                                                         │  │
│  │    U, Vh  -> rotation matrices [n_particles, 2, 2]                  │  │
│  │    sig    -> singular values (stretches) [n_particles, 2]           │  │
│  │    J      -> det(F) = sig1*sig2 = torch.prod(sig)                   │  │
│  └─────────────────────────────────────────────────────────────────────┘  │
│                                   │                                      │
│      ┌─────────────────────────────┼─────────────────────────────┐        │
│      ▼                             ▼                             ▼        │
│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐  │
│  │    LIQUID     │          │     JELLY     │          │     SNOW      │  │
│  │   (T == 0)    │          │   (T == 1)    │          │   (T == 2)    │  │
│  ├───────────────┤          ├───────────────┤          ├───────────────┤  │
│  │ mu = 0        │          │ h = 0.3       │          │ h = exp(10*   │  │
│  │ (no shear)    │          │ (constant)    │          │    (1-Jp))    │  │
│  │               │          │               │          │               │  │
│  │ F = sqrt(J)*I │          │ sig clamped   │          │ sig clamped   │  │
│  │ (isotropic)   │          │ F = U*Sig*V^T │          │ [0.975,1.0045]│  │
│  │               │          │               │          │ Jp updated    │  │
│  └───────────────┘          └───────────────┘          └───────────────┘  │
│      │                             │                             │        │
│      └─────────────────────────────┼─────────────────────────────┘        │
│                                    ▼                                      │
│  Code references:                                                        │
│    - Hardening: h = torch.exp(10 * (1.0 - Jp.squeeze()))     Line 51    │
│    - Jelly h:   h = torch.where(jelly_mask, 0.3, h)          Line 52    │
│    - Lame:      mu = mu_0 * h, la = lambda_0 * h             Lines 55-56│
│    - Liquid mu: mu = torch.where(liquid_mask, 0.0, mu)       Line 57    │
│    - Snow clamp: sig = torch.clamp(sig, 1-2.5e-2, 1+4.5e-3)  Line 98    │
│    - Jp update: Jp = Jp * plastic_ratio                      Line 102   │
│    - Liquid F:  F_liquid = identity * sqrt(J)                Line 112   │
│    - Solid F:   F_solid = U @ sig_diag @ Vh                  Line 113   │
└───────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 2: STRESS COMPUTATION                                               ║
║                                                                           ║
║    R = U * V^T                   (rotation component)                     ║
║                                                                           ║
║    stress = 2*mu*(F-R)*F^T + la*J*(J-1)*I   (Cauchy, corotated model)     ║
║                                                                           ║
║  Code:                                                                    ║
║    R = U @ Vh                                                 Line 123   ║
║    F_minus_R = F - R                                          Line 124   ║
║    stress = (2*mu*(F-R)@F^T + la*J*(J-1)*I)                  Line 125-126║
║    stress = (-dt * p_vol * 4 * inv_dx^2) * stress            Line 127    ║
║                                                                           ║
║  The scaling factor converts stress to force for P2G transfer             ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
┌───────────────────────────────────────────────────────────────────────────┐
│  STEP 2->3: AFFINE MOMENTUM COMPUTATION                                   │
│                                                                           │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │                                                                    │   │
│  │     affine = stress + m * C                                        │   │
│  │                                                                    │   │
│  │  Code: affine = stress + p_mass.unsqueeze(-1).unsqueeze(-1) * C   │   │
│  │                                                       Line 162    │   │
│  │                                                                    │   │
│  │  Physical interpretation:                                          │   │
│  │    - stress term: internal forces from deformation                 │   │
│  │    - m*C term: momentum transport (APIC angular momentum)          │   │
│  │                                                                    │   │
│  │  This combined "affine" carries BOTH force AND momentum info       │   │
│  │  to the grid in a single transfer.                                 │   │
│  └────────────────────────────────────────────────────────────────────┘   │
│                                                                           │
│  Variables at this point:                                                 │
│  ┌────────────┬─────────────┬─────────────────────────────────────────┐   │
│  │ Variable   │ Shape       │ Description                             │   │
│  ├────────────┼─────────────┼─────────────────────────────────────────┤   │
│  │ stress     │ [N, 2, 2]   │ Scaled stress (force)                   │   │
│  │ C          │ [N, 2, 2]   │ Affine velocity matrix                  │   │
│  │ p_mass     │ [N]         │ Particle mass                           │   │
│  │ affine     │ [N, 2, 2]   │ Combined force + momentum gradient      │   │
│  └────────────┴─────────────┴─────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 3: P2G TRANSFER (Particle to Grid)                                  ║
║                                                                           ║
║  Each particle i CONTRIBUTES to its 9 neighboring grid nodes j:           ║
║                                                                           ║
║    contribution to mass:     dm_j = w_j * m_i                             ║
║    contribution to momentum: dp_j = w_j * (m_i*v_i + Q_i*(x_j - x_i))     ║
║                                                                           ║
║  The GNN ACCUMULATES all particle contributions at each grid node:        ║
║                                                                           ║
║    m_j = SUM_i dm_j   (total mass at node j)                              ║
║    p_j = SUM_i dp_j   (total momentum at node j)                          ║
║                                                                           ║
║  Code (MPM_P2G.message computes d, GNN aggregation computes SUM):         ║
║    out_m = mass_j * weights              # dm_j contribution              ║
║    out_v = weights * (m*v + Q @ dpos)    # dp_j contribution              ║
║                                                                           ║
║  After GNN aggregation (Line 214-216):                                    ║
║    grid_m = accumulated mass m_j     [n_grid, n_grid]                     ║
║    grid_v = accumulated momentum p_j [n_grid, n_grid, 2] (NOT velocity!)  ║
║                                                                           ║
║  Weights: Quadratic B-spline w0, w1, w2                     Lines 178-181 ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 4: GRID OPERATIONS                                                  ║
║                                                                           ║
║    v_j = p_j / m_j               (momentum -> velocity, using accumulated)║
║    v_j += dt * g                 (gravity)                                ║
║    Apply boundary conditions     (friction, no-penetration)               ║
║                                                                           ║
║  Code:                                                                    ║
║    grid_v = grid_v / (grid_m + eps)                         Line 226-228  ║
║    grid_v = grid_v + gravity_force                          Line 232-234  ║
║    Boundary handling                                        Lines 242-266 ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 5: G2P TRANSFER                                                     ║
║                                                                           ║
║    v_i = SUM_j w_j * v_j              (APIC velocity update)              ║
║                                                                           ║
║    C_i = 4/dx^2 * SUM_j w_j * v_j (x) (x_j - x_i)   (affine velocity)     ║
║                                                                           ║
║  Code:                                                                    ║
║    new_V = SUM weights * g_v_all                            Line 304-305  ║
║    outer_products = g_v @ dpos^T                            Line 309-311  ║
║    new_C = 4 * inv_dx * SUM weights * outer_products        Line 315      ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
╔═══════════════════════════════════════════════════════════════════════════╗
║  STEP 6: ADVECTION                                                        ║
║                                                                           ║
║    x_i = x_i + dt * v_i                                                   ║
║                                                                           ║
║  Code: X = X + dt * new_V                                       Line 322  ║
╚═══════════════════════════════════════════════════════════════════════════╝
                                   │
                                   ▼
OUTPUT STATE: X, V, C, F, Jp (updated)
```

## Variable Reference Table

| Code Variable | Math Symbol | Shape | Physical Meaning | Units |
|:--------------|:------------|:------|:-----------------|:------|
| `X` | $\mathbf{x}_i$ | `[N, 2]` | Particle position | m |
| `V` | $\mathbf{v}_i$ | `[N, 2]` | Particle velocity | m/s |
| `C` | $\mathbf{C}_i$ | `[N, 2, 2]` | Affine velocity matrix (velocity gradient) | 1/s |
| `F` | $\mathbf{F}_i$ | `[N, 2, 2]` | Deformation gradient | - |
| `Jp` | $J_p$ | `[N, 1]` | Plastic volume ratio (accumulated) | - |
| `T` | type | `[N, 1]` | Material type index | - |
| `M` | $m_i$ | `[N, 1]` | Particle mass | kg |
| `U` | $\mathbf{U}$ | `[N, 2, 2]` | Left rotation (from SVD) | - |
| `sig` | $\boldsymbol{\sigma}$ | `[N, 2]` | Singular values (stretches) | - |
| `Vh` | $\mathbf{V}^T$ | `[N, 2, 2]` | Right rotation transposed | - |
| `R` | $\mathbf{R}$ | `[N, 2, 2]` | Rotation matrix $\mathbf{U}\mathbf{V}^T$ | - |
| `J` | $J$ | `[N]` | Volume ratio $\det(\mathbf{F})$ | - |
| `h` | $h$ | `[N]` | Hardening factor | - |
| `mu` | $\mu$ | `[N]` | Shear modulus | Pa |
| `la` | $\lambda$ | `[N]` | First Lame parameter | Pa |
| `stress` | $\boldsymbol{\sigma}$ | `[N, 2, 2]` | Cauchy stress (scaled) | N |
| `affine` | $\mathbf{Q}$ | `[N, 2, 2]` | Affine momentum $\sigma + m\mathbf{C}$ | N |
| `grid_m` | $m_j$ | `[G, G]` | Grid mass (accumulated) | kg |
| `grid_v` | $\mathbf{p}_j$ | `[G, G, 2]` | Grid momentum (accumulated, NOT velocity!) | kg·m/s |
| `w` | $w$ | `[N, 3, 2]` | B-spline weights | - |

## Key Equations Summary

### Deformation Update
$$\mathbf{F}^{n+1} = (\mathbf{I} + \Delta t \, \mathbf{C}^n) \mathbf{F}^n$$

### SVD Decomposition
$$\mathbf{F} = \mathbf{U} \, \text{diag}(\sigma_1, \sigma_2) \, \mathbf{V}^T$$

### Hardening (Snow)
$$h = \exp\bigl(10(1 - J_p)\bigr)$$

### Lame Parameters
$$\mu = \mu_0 \cdot h, \quad \lambda = \lambda_0 \cdot h$$

### Cauchy Stress (Fixed Corotated)
$$\boldsymbol{\sigma} = 2\mu (\mathbf{F} - \mathbf{R}) \mathbf{F}^T + \lambda J (J-1) \mathbf{I}$$

### Affine Momentum
$$\mathbf{Q} = \boldsymbol{\sigma}_{\text{scaled}} + m \, \mathbf{C}$$

### P2G Transfer

**Step 1: Each particle contributes to neighboring grid nodes**
$$\delta m_j = w_j \, m_i, \quad \delta \mathbf{p}_j = w_j \bigl(m_i \mathbf{v}_i + \mathbf{Q} \cdot (\mathbf{x}_j - \mathbf{x}_i)\bigr)$$

**Step 2: GNN accumulates all contributions at each node**
$$m_j = \sum_i \delta m_j, \quad \mathbf{p}_j = \sum_i \delta \mathbf{p}_j$$

### Grid Operations (uses accumulated values)
$$\mathbf{v}_j = \mathbf{p}_j / m_j \quad \text{(momentum} \to \text{velocity)}$$

### G2P Transfer (APIC)
$$\mathbf{v}_i = \sum_j w_j \, \mathbf{v}_j, \quad \mathbf{C}_i = \frac{4}{\Delta x^2} \sum_j w_j \, \mathbf{v}_j \otimes (\mathbf{x}_j - \mathbf{x}_i)$$

### Advection
$$\mathbf{x}^{n+1} = \mathbf{x}^n + \Delta t \, \mathbf{v}^{n+1}$$

## The Affine Term Explained

The key insight is that **affine = stress + m·C** combines two physical effects:

::: {.callout-important}
## Why stress + m·C?

1. **stress term**: Internal forces from material deformation. This is what creates elastic/plastic behavior.

2. **m·C term**: The APIC (Affine Particle-In-Cell) contribution. This preserves angular momentum and prevents numerical dissipation.

Each particle's contribution to grid momentum is:
$$\delta \mathbf{p}_j = w_j \cdot \bigl[\underbrace{m_i \mathbf{v}_i}_{\text{linear momentum}} + \underbrace{\mathbf{Q}}_{\text{affine}} \cdot \underbrace{(\mathbf{x}_j - \mathbf{x}_i)}_{\text{dpos}}\bigr]$$

This single transfer carries both **force** (from stress) and **momentum gradient** (from C) information.
:::

## Material-Specific Behavior

```
                    ┌───────────────┐
                    │    F update   │
                    │ F=(I+dt*C)*F  │
                    └───────┬───────┘
                            │
                    ┌───────▼───────┐
                    │      SVD      │
                    │  F = U*Sig*V^T│
                    └───────┬───────┘
                            │
         ┌──────────────────┼──────────────────┐
         ▼                  ▼                  ▼
   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐
   │   LIQUID    │   │    JELLY    │   │    SNOW     │
   │   (T=0)     │   │    (T=1)    │   │    (T=2)    │
   ├─────────────┤   ├─────────────┤   ├─────────────┤
   │ mu = 0      │   │ h = 0.3     │   │ h=e^10(1-Jp)│
   │             │   │ mu = mu0*h  │   │ mu = mu0*h  │
   │ F = sqrt(J) │   │ F = U*Sig*V │   │ Sig clamped │
   │     * I     │   │             │   │ Jp updated  │
   │ (isotropic) │   │             │   │ F = U*Sig*V │
   └──────┬──────┘   └──────┬──────┘   └──────┬──────┘
          │                 │                 │
          └─────────────────┼─────────────────┘
                            ▼
                    ┌───────────────┐
                    │    Stress     │
                    │ s=2mu(F-R)F^T │
                    │  +la*J(J-1)I  │
                    └───────┬───────┘
                            ▼
                    ┌───────────────┐
                    │    Affine     │
                    │  Q = s + m*C  │
                    └───────┬───────┘
                            ▼
                       P2G transfer
```
